

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Nanodiffraction &mdash; nanodiffraction 1.0 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Display" href="../display/displayAPI.html" />
    <link rel="prev" title="Files" href="../files/filesAPI.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> nanodiffraction
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../getting_started/getting_started.html">Getting Started</a></li>
</ul>
<p class="caption"><span class="caption-text">Working with the toolbox</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../guide/guide.html">Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../geometry/geometry.html">Geometry</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mex/mex.html">Mex-functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../colormaps/colormaps.html">Colormaps</a></li>
</ul>
<p class="caption"><span class="caption-text">Toolbox functionality</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../files/files.html">Files module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../nanodiffraction/nanodiffraction.html">Nanodiffraction module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../display/display.html">Display module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../functions/functions.html">External functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dependencies/dependencies.html">External dependencies</a></li>
</ul>
<p class="caption"><span class="caption-text">References</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../references/references.html">References</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../matlab.html">Matlab API</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../files/filesAPI.html">Files</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Nanodiffraction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../display/displayAPI.html">Display</a></li>
<li class="toctree-l2"><a class="reference internal" href="../functions/functionsAPI.html">Functions</a></li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">nanodiffraction</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../matlab.html">Matlab API</a> &raquo;</li>
        
      <li>Nanodiffraction</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../_sources/matlab/nanodiffraction/nanodiffractionAPI.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="module-&#64;nanodiffraction">
<span id="nanodiffraction"></span><span id="nanodiffractionapi"></span><h1>Nanodiffraction<a class="headerlink" href="#module-@nanodiffraction" title="Permalink to this headline">¶</a></h1>
<dl class="class">
<dt id="&#64;nanodiffraction.nanodiffraction">
<em class="property">class </em><code class="descclassname">&#64;nanodiffraction.</code><code class="descname">nanodiffraction</code><span class="sig-paren">(</span><em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@nanodiffraction.nanodiffraction" title="Permalink to this definition">¶</a></dt>
<dd><p>NANODIFFRACTION  Class that defines the experimental geometry and
calculates geometrical parameters accordingly.
The key method is ‘’ that is used to process x-ray
diffraction data obtained from scanning experiments.</p>
<blockquote>
<div><code class="docutils literal notranslate"><span class="pre">EXPERIMENT</span> <span class="pre">=</span> <span class="pre">NANODIFFRACTION()</span></code> creates an object, an
experiment, with a list of key-value pairs. See further below for a
list of keys and possible values.</div></blockquote>
<p>The nanodiffraction class holds two types of parameters,
experiment-specific parameters and scan parameters. In
addition, it contains smaller useful helper functions such as
q_of_n() that takes in pixel coordinates and transforms them into q
coordinates. Here is a short description of the available helper
functions stored in <code class="docutils literal notranslate"><span class="pre">EXPERIMENT.helper</span></code></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">n_of_q(qr)</span></code>:</dt>
<dd>Requires a reciprocal wavevector coordinate and
calculates the according pixel coordinate</dd>
<dt><code class="docutils literal notranslate"><span class="pre">q_of_n(n)</span></code>:</dt>
<dd>Requires a pixel coordinate and calculates the
according reciprocal wavevector coordinate</dd>
<dt><code class="docutils literal notranslate"><span class="pre">twoTh_of_n(n)</span></code>:</dt>
<dd>Requires a pixel coordinate and calculates the
according scattering angle 2*theta</dd>
<dt><code class="docutils literal notranslate"><span class="pre">to1dcol(x)</span></code>:</dt>
<dd>Requires a 2d array x and transforms this array into a
1d column vector</dd>
<dt><code class="docutils literal notranslate"><span class="pre">to1drow(x)</span></code>:</dt>
<dd>Requires a 2d array x and transforms this array into a
1d row vector</dd>
<dt><code class="docutils literal notranslate"><span class="pre">to2d(x,ny,nz)</span></code>:</dt>
<dd>Requires a 1d array x and transforms this array
into a 2d array with dimensions (nz,ny)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">reduce(i,start,skip)</span></code>:</dt>
<dd>Simplified indexing</dd>
<dt><code class="docutils literal notranslate"><span class="pre">simplify_sf(data)</span></code>:</dt>
<dd>Not used</dd>
<dt><code class="docutils literal notranslate"><span class="pre">scale(x)</span></code>:</dt>
<dd>Requires a 2d array x and rescales the array into the
range (0,1) based on the minimum and maximum values in the array</dd>
<dt><code class="docutils literal notranslate"><span class="pre">scaleH(x,h)</span></code>:</dt>
<dd>Requires a 2d array x and rescales the array into the
range (0,h) based on the minimum and maximum values in the array
and the high value h</dd>
<dt><code class="docutils literal notranslate"><span class="pre">scaleLH(x,l,h)</span></code>:</dt>
<dd>Requires a 2d array x and rescales the array into
the range (l,h) based on the minimum and maximum values in the
array and the low value l and the high value h</dd>
<dt><code class="docutils literal notranslate"><span class="pre">clipL(x,l)</span></code>:</dt>
<dd>Requires a 1d or 2d array x. Values below the clipping
value l will be set to l.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">clipH(x,h)</span></code>:</dt>
<dd>Requires a 1d or 2d array x. Values above the clipping
value h will be set to h.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">clipLH(x,l,h)</span></code>:</dt>
<dd>Requires a 1d or 2d array x. Values below the
clipping value l will be set to l and values above the clipping
value h will be set to h.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">autoClip(x)</span></code>:</dt>
<dd>Requires a 1d or 2d array and calculates the 5%
low and high percentile.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">getIndex(x,xloc)</span></code>:</dt>
<dd>Calculates the closest linear index in the 1d
array x based on the query value xloc</dd>
<dt><code class="docutils literal notranslate"><span class="pre">addTransp(transp)</span></code>:</dt>
<dd>Overlays a transparency map over the current
figure. Values in the transparency map should range between (0,1)
and the size of the transparency map has to match the size of the
data in the figure</dd>
<dt><code class="docutils literal notranslate"><span class="pre">normDist(x)</span></code>:</dt>
<dd>Removes the mean and divides by the standard
deviation of a distribution x.</dd>
</dl>
<p>In order to perform calculations on real data, one has to couple
the nanodiffraction class to the files class to “tell the
experiment, where the data is stored”. This can be achieved by using
the function <code class="docutils literal notranslate"><span class="pre">nanodiffraction.attach()</span></code> (see <code class="docutils literal notranslate"><span class="pre">help</span> <span class="pre">attach</span></code> for
usage information).</p>
<p>Furthermore, three other properties of the nanodiffraction class
are of interest:</p>
<blockquote>
<div><dl class="docutils">
<dt>nanodiffraction.mask:</dt>
<dd>A bad pixel mask can be set using the function set_mask().</dd>
<dt>nanodiffraction.sels</dt>
<dd>A mask identifying pixels that shall be analyzed can be
defined using set_selection(). More selections can be added
using add_selection(). This is useful since data has to be
read only once, while the analysis can be performed
multiple times on the same data (but different selections).
In many cases it is useful to use the functions
radial_mask() and azimuthal_mask() in order to define
selections.</dd>
<dt>nanodiffraction.corr</dt>
<dd>A correction matrix that will be multiplied with the data
prior to the analysis to compensate for semi-transparent
objects such as glass capillaries.</dd>
</dl>
</div></blockquote>
<dl class="docutils">
<dt>The following options are supported:</dt>
<dd><dl class="first last docutils">
<dt>energy: [0] (not necessary if wavenumber or wavelength are given)</dt>
<dd>x-ray photon energy in [eV]</dd>
<dt>wavenumber: [0] (not necessary if energy or wavelength are given)</dt>
<dd>x-ray photon wavenumber in [m^-1]</dd>
<dt>wavelength: [0] (not necessary if wavenumber or energy are given)</dt>
<dd>x-ray photon wavelength in [m]</dd>
<dt>detDistance: [5]</dt>
<dd>detector distance in [m]</dd>
<dt>pixelsize: [172E-6]</dt>
<dd>detector pixel size in [m]</dd>
<dt>Ny: [487]</dt>
<dd>number of detector pixels along y axis (horizontal axis)</dd>
<dt>Nz: [619]</dt>
<dd>number of detector pixels along z axis (vertical axis)</dd>
<dt>pby: [1]</dt>
<dd>horizontal primary beam position relative to first pixel in
top-left corner (when viewed along beam propagation direction)</dd>
<dt>pbz: [1]</dt>
<dd>vertical primary beam position relative to first pixel in
top-left corner (when viewed along beam propagation direction)</dd>
<dt>fluoCounters: [{}]</dt>
<dd>Cell array of thresholds to generate maps of different element
distributions</dd>
</dl>
</dd>
</dl>
<p class="rubric">Example</p>
<p>See the following example for help:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">experiment</span> <span class="p">=</span>
<span class="n">nanodiffraction</span><span class="p">(</span><span class="s">&#39;energy&#39;</span><span class="p">,</span><span class="mf">12.8e3</span><span class="p">,</span><span class="s">&#39;detDistance&#39;</span><span class="p">,</span><span class="mf">1.2</span><span class="p">,</span><span class="c">...</span>
<span class="s">&#39;pby&#39;</span><span class="p">,</span><span class="mf">121.2</span><span class="p">,</span><span class="s">&#39;pby&#39;</span><span class="p">,</span><span class="mf">144.1</span><span class="p">,</span><span class="c">...</span>
<span class="s">&#39;Ny&#39;</span><span class="p">,</span><span class="mi">1100</span><span class="p">,</span><span class="s">&#39;Nz&#39;</span><span class="p">,</span><span class="mi">1220</span><span class="p">,</span><span class="c">...</span>
<span class="s">&#39;fluoCounters&#39;</span><span class="p">,{{</span><span class="s">&#39;total&#39;</span><span class="p">,</span><span class="mi">1</span> <span class="mi">4100</span><span class="p">},{</span><span class="s">&#39;caka&#39;</span><span class="p">,</span><span class="mi">600</span><span class="p">,</span><span class="mi">660</span><span class="p">}});</span>
</pre></div>
</div>
<dl class="method">
<dt>
<code class="descname">See seperate help for each method. Also, refer to the methods</code></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="descname">summary in ``doc nanodiffraction``.</code></dt>
<dd></dd></dl>

<p>Copyright 2017 Institute for X-ray Physics (University of Göttingen)</p>
<p>Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the ‘’),
to deal in the Software without restriction, including without limitation
the rights to use, copy, modify, merge, publish, distribute, sublicense,
and/or sell copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following conditions:</p>
<p>The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.</p>
<p>THE SOFTWARE IS PROVIDED ‘’, WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>
<dl class="method">
<dt id="&#64;nanodiffraction.nanodiffraction.add_selection">
<code class="descname">add_selection</code><span class="sig-paren">(</span><em>sel</em><span class="sig-paren">)</span><a class="headerlink" href="#@nanodiffraction.nanodiffraction.add_selection" title="Permalink to this definition">¶</a></dt>
<dd><p>ADD_SELECTION  The function adds a logical selection matrix
to the current stack of selections.</p>
<blockquote>
<div><code class="docutils literal notranslate"><span class="pre">selections</span> <span class="pre">=</span> <span class="pre">add_selection(selection)</span></code></div></blockquote>
<dl class="docutils">
<dt>The following arguments are supported:</dt>
<dd><dl class="first last docutils">
<dt>selection: []</dt>
<dd>A two-dimensional array. The input should be a logical
array.</dd>
</dl>
</dd>
</dl>
<p class="rubric">Example</p>
<p>See the following example for help:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">e</span> <span class="p">=</span> <span class="n">nanodiffraction</span><span class="p">(</span><span class="o">&lt;</span><span class="n">some</span> <span class="n">settings</span><span class="o">&gt;</span><span class="p">);</span>
<span class="n">sel_small</span> <span class="p">=</span> <span class="n">e</span><span class="p">.</span><span class="n">radial_mask</span><span class="p">(</span><span class="s">&#39;r1&#39;</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="s">&#39;r2&#39;</span><span class="p">,</span><span class="mf">1.2</span><span class="p">,</span><span class="s">&#39;grid&#39;</span><span class="p">,</span><span class="n">e</span><span class="p">.</span><span class="n">qr</span><span class="p">);</span>
<span class="n">sel_large</span> <span class="p">=</span> <span class="n">e</span><span class="p">.</span><span class="n">radial_mask</span><span class="p">(</span><span class="s">&#39;r1&#39;</span><span class="p">,</span><span class="mf">2.4</span><span class="p">,</span><span class="s">&#39;r2&#39;</span><span class="p">,</span><span class="mf">3.2</span><span class="p">,</span><span class="s">&#39;grid&#39;</span><span class="p">,</span><span class="n">e</span><span class="p">.</span><span class="n">qr</span><span class="p">);</span>
<span class="n">sel_all</span> <span class="p">=</span> <span class="nb">ones</span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">Nz</span><span class="p">,</span><span class="n">e</span><span class="p">.</span><span class="n">Ny</span><span class="p">);</span>
<span class="n">e</span><span class="p">.</span><span class="n">set_selection</span><span class="p">(</span><span class="n">sel_all</span><span class="p">);</span>
<span class="n">e</span><span class="p">.</span><span class="n">add_selection</span><span class="p">(</span><span class="n">sel_small</span><span class="p">);</span>
<span class="n">e</span><span class="p">.</span><span class="n">add_selection</span><span class="p">(</span><span class="n">sel_large</span><span class="p">);</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Output arguments:</dt>
<dd><dl class="first last docutils">
<dt>selections:</dt>
<dd>Current set of selections.</dd>
</dl>
</dd>
</dl>
<div class="line-block">
<div class="line">Note, that the selections are stored in:</div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">(nanodiffraction_class).sels</span></code></div>
</div>
</dd></dl>

<dl class="method">
<dt id="&#64;nanodiffraction.nanodiffraction.analyze_scan">
<code class="descname">analyze_scan</code><span class="sig-paren">(</span><em>method</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@nanodiffraction.nanodiffraction.analyze_scan" title="Permalink to this definition">¶</a></dt>
<dd><p>ANALYZE_SCAN  Main method of nanodiffraction class. It
analyzes a scan based on several implemented methods that can
be chosen in a random order and combination. However,
corrections are always performed before any subsequent
analysis. The ‘’ functionality has a special role, as
it is a method but is always performed before any other
analysis but after background and other corrections, for
obvious reasons.</p>
<blockquote>
<div><code class="docutils literal notranslate"><span class="pre">RESULT</span> <span class="pre">=</span> <span class="pre">ANALYZE_SCAN(method,options)</span></code> outputs the results as a
struct where each entry in the struct is named after the
method that was chosen for analysis. All relevant data can
be found therein.</div></blockquote>
<dl class="docutils">
<dt>The following arguments are accepted:</dt>
<dd><blockquote class="first">
<div><dl class="docutils">
<dt>method: [] (required)</dt>
<dd><p class="first">A string composed of the following options: ‘debug’,
‘rotate’,’pca’,’stxm’,’maxProj’,’crystal’,’fluo’,
‘average’,’sum’,’data’,’circDist’.
Methods can be combined using a ‘+’ symbol between the
methods:</p>
<p class="last">e.g. <code class="docutils literal notranslate"><span class="pre">'stxm+pca+maxProj+sum'</span></code></p>
</dd>
</dl>
</div></blockquote>
<dl class="last docutils">
<dt>options: [] (optional)</dt>
<dd><blockquote class="first">
<div><p>Structure that can contain the following fields. Note,
that all fields are optional. Default values that are
otherwise used are as usual given in angle brackets:</p>
<dl class="docutils">
<dt>roi: []</dt>
<dd>A logical mask of size SNy x SNz. A logical (1)
indicates a scan point that will be analyzed.</dd>
<dt>yCrop, zCrop: [start end]</dt>
<dd>Start and end can be given to define a certain
range within the scan to be analyzed.</dd>
</dl>
</div></blockquote>
<dl class="last docutils">
<dt>ySkip, zSkip: [1]</dt>
<dd><blockquote class="first">
<div>If only every n-th scan point should be analyzed</div></blockquote>
<dl class="last docutils">
<dt>emptySub: [‘off’]</dt>
<dd><p class="first">Subtracts an empty image from the data immediately
after the data has been read. If an empty image is
given (see keyword ‘empty’), it will be used,
otherwise, it will be attempted to use the empty image
that was defined at an earlier stage using
set_empty().</p>
<p class="last">Options: ‘on’ | ‘off’</p>
</dd>
<dt>correction: [‘off’]</dt>
<dd><p class="first">Multiplies a 2d
correction matrix with the data. E.g. used to account
for semitransparent objects obscuring the detector</p>
<p class="last">Options: ‘on’ | ‘off’</p>
</dd>
<dt>fluoCounters: [{}]</dt>
<dd><p class="first">The format is {{&lt;name&gt;,&lt;channel_low&gt;,&lt;channel_high&gt;},…},</p>
<p class="last">e.g. <code class="docutils literal notranslate"><span class="pre">{{'caka',1000,1400},{},...}</span></code></p>
</dd>
<dt>parallel: [‘off’]</dt>
<dd>When turned on, all available workers will be used to
speed up the calculation process.
Warning: This is currently only implemented for the
stxm method.</dd>
<dt>scanmode: [‘horz’]</dt>
<dd><p class="first">See description below.</p>
<p class="last">Options: ‘horz’|’horzalt’|’vert’|’vertalt’</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p>Some methods can be given a set of arguments in a struct.
Note, that all struct parameters are optional. If some or all
arguments are not given, then default values will be used, as
indicated in paranthesis [default value].</p>
<blockquote>
<div><dl class="docutils">
<dt>pca:</dt>
<dd><p class="first">Performs a PCA analysis as e.g. demonstrated in
Bernhardt, et.al., X-Ray Micro- and Nanodiffraction Imaging
on Human Mesenchymal Stem Cells and Differentiated Cells,
Biophys. J. (2016), 110, 680-690.</p>
<dl class="last docutils">
<dt>PARAMETER ARGUMENTS: ‘pcaArgs’,struct()</dt>
<dd><p class="first">struct() can take the following arguments:</p>
<dl class="last docutils">
<dt>‘qy’:</dt>
<dd>2d array of horizontal wavevector transfer [repmat(obj.qyaxis ,obj.Nz,1)]</dd>
<dt>‘qz’:</dt>
<dd>2d array of vertical wavevector transfer [repmat(obj.qzaxis’,1,obj.Ny)]</dd>
<dt>‘sel’:</dt>
<dd>Logical 2d array. A value of 1 represents a pixel that will be analyzed [obj.sels]</dd>
<dt>‘mask’:</dt>
<dd>Logical 2d array. A value of 1 represents a pixel that will be discarded [obj.mask]</dd>
</dl>
</dd>
</dl>
</dd>
<dt>stxm:</dt>
<dd><p class="first">Integrates the scattered intensity of each
diffraction pattern (darkfield contrast).</p>
<dl class="last docutils">
<dt>PARAMETER ARGUMENTS: ‘stxmArgs’,struct()</dt>
<dd><p class="first">struct() can take the following arguments:</p>
<dl class="last docutils">
<dt>‘qrMin’:</dt>
<dd>Only pixels above the radial wavevector transfer qrMin will be analyzed [-1]</dd>
<dt>‘qrMax’:</dt>
<dd>Only pixels below the radial wavevector transfer qrMax will be analyzed [-1]</dd>
<dt>‘sel’:</dt>
<dd>Logical 2d array. A value of 1 represents a pixel that will be analyzed [ones(obj.Nz,oabj.Ny))]</dd>
<dt>‘mask’:</dt>
<dd>Logical 2d array. A value of 1 represents a pixel that will be discarded [obj.mask]</dd>
</dl>
</dd>
</dl>
</dd>
<dt>circDist:</dt>
<dd><p class="first">Calculates the circular mean and circular’grid’,obj.phi2,’bins’,360,’sel’,obj.sels,’mask’,obj.mask,’bgr’,[]),…
variance of a distribution. Here, used to calculate the
circular mean of I(phi) for a given qr-Interval.</p>
<dl class="last docutils">
<dt>PARAMETER ARGUMENTS: ‘circDistArgs’,struct()</dt>
<dd><p class="first">struct() can take the following arguments:</p>
<dl class="last docutils">
<dt>‘grid’:</dt>
<dd>Pixel map of azimuthal coordinates [obj.phi2]</dd>
<dt>‘bins’:</dt>
<dd>Number of azimuthal bins [360]</dd>
<dt>‘bgr’:</dt>
<dd>2d background image that is going to be subtracted before the mean scattering angle is determined []</dd>
<dt>‘sel’:</dt>
<dd>Logical 2d array. A value of 1 represents a pixel that will be analyzed [obj.sels]</dd>
<dt>‘mask’:</dt>
<dd>Logical 2d array. A value of 1 represents a pixel that will be discarded [obj.mask]</dd>
</dl>
</dd>
</dl>
</dd>
<dt>maxProjection:</dt>
<dd>Calculates the maximum projection of a stack of
diffraction patterns. No arguments are required.</dd>
<dt>maxProj:</dt>
<dd>Synonymous to maxProjection</dd>
<dt>mp:</dt>
<dd>Synonymous to maxProjection</dd>
<dt>crystal:</dt>
<dd><p class="first">Performs a thresholding for crystal mapping based
on SNR criterium.</p>
<dl class="last docutils">
<dt>PARAMETER ARGUMENTS: ‘crystalArgs’,struct()</dt>
<dd><p class="first">struct() can take the following arguments:</p>
<dl class="last docutils">
<dt>‘bgr’:</dt>
<dd>2d background image that is going to be subtracted before the summing procedure [zeros(obj.Nz,obj.Ny)]</dd>
<dt>‘threshold’:</dt>
<dd>All pixels with counts above threshold will be summed [50]</dd>
<dt>‘qrMin’:</dt>
<dd>Only pixels above the radial wavevector transfer qrMin will be analyzed [0]</dd>
<dt>‘qrMax’:</dt>
<dd>Only pixels below the radial wavevector transfer qrMax will be analyzed [100]</dd>
<dt>‘sel’:</dt>
<dd>Logical 2d array. A value of 1 represents a pixel that will be analyzed [obj.sels]</dd>
<dt>‘mask’:</dt>
<dd>Logical 2d array. A value of 1 represents a pixel that will be discarded [obj.mask]</dd>
</dl>
</dd>
</dl>
</dd>
<dt>pyfai:</dt>
<dd><p class="first">Fast azimuthal integration based on the python pyfai
library.</p>
<dl class="last docutils">
<dt>PARAMETER ARGUMENTS: ‘pyfaiArgs’,struct()</dt>
<dd><p class="first">struct() can take the following arguments:</p>
<dl class="last docutils">
<dt>‘bins’:</dt>
<dd>Number of bins along radial axis [100]</dd>
<dt>‘mask’:</dt>
<dd>Logical 2d array. A value of 1 represents a pixel that will be discarded []</dd>
<dt>‘cake’:</dt>
<dd>Toggle cake integration, can be either ‘on’ or ‘off’ [off]</dd>
<dt>‘cakeRoi’:</dt>
<dd>If ‘cake’ is ‘on’, then cakeRoi can be set within a range (phi1,phi2), where phi1 and phi2 are angles in degrees within the range (0,360) and phi2 should be smaller than phi1 [0 360]</dd>
<dt>‘angles’: []</dt>
<dd>Missing description.</dd>
<dt>‘to2D’:</dt>
<dd>Can be either ‘on’ or ‘off’. If ‘on’, then the 2d regridded pattern is output [‘off’]</dd>
<dt>‘roi2d’: [‘off’]</dt>
<dd>Missing description.</dd>
</dl>
</dd>
</dl>
</dd>
<dt>b1d:</dt>
<dd><p class="first">Fast azimuthal integration based on rebinning the
data.</p>
<dl class="last docutils">
<dt>PARAMETER ARGUMENTS: ‘b1dArgs’,struct()</dt>
<dd><dl class="first last docutils">
<dt>struct() can take the following arguments:</dt>
<dd><dl class="first last docutils">
<dt>‘grid’:</dt>
<dd>Pixel coordinates, e.g. a 2d map of the radial wavevector transfer [obj.qr]</dd>
<dt>‘bins’:</dt>
<dd>Number of bins along radial axis [100]</dd>
<dt>‘sel’:</dt>
<dd>Logical 2d array. A value of 1 represents a pixel that will be analyzed [ones(obj.Nz,obj.Ny)]</dd>
<dt>‘mask’:</dt>
<dd>Logical 2d array. A value of 1 represents a pixel that will be discarded [obj.mask]</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt>symmetry:</dt>
<dd><p class="first">Identifies reflections in the data at calculates
rotational order. Used e.g. in Carboni and Nicolas et al.
(2017), Imaging of neuronal tissues by x-ray diffraction
and x-ray fluorescence microscopy: evaluation of contrast
and biomarkers for neurodegenerative diseases, Biomedical
Optics Express 8 (10), pp. 4331-4347.</p>
<dl class="last docutils">
<dt>PARAMETER ARGUMENTS: ‘symmetryArgs’,struct()</dt>
<dd><dl class="first last docutils">
<dt>struct() can take the following arguments:</dt>
<dd><dl class="first last docutils">
<dt>‘bgr’:</dt>
<dd>2d background image that is going to be subtracted before the summing procedure [zeros(obj.Nz,obj.Ny)]</dd>
<dt>‘sigma’:</dt>
<dd>Parameter of Gaussian filter [1.6]</dd>
<dt>‘noise_level’:</dt>
<dd>SNR level that functions as a threshold for peak detection [6]</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt>heal:</dt>
<dd><p class="first">Heals a scattering pattern by filling values were
data has been lost or not recorded by reflecting measured
data from the point-symmetric location.
Note, that heal is executed before all other methods, such
that the healed data can be used for the subsequent analysis.</p>
<p class="last">PARAMETER ARGUMENTS: ‘healMask’: 2d logical masks that
identifies bad or corrupted pixels that should be
recovered.</p>
</dd>
<dt>fluo:</dt>
<dd>Integrates response within a pre-defined channel
range for each given counter. Note, that fluoCounters have
to be defined beforehand. Either during initialization or
afterwards using e.g. &gt; obj.fluoCounters = {{‘caka’},{200
500}};</dd>
<dt>average:</dt>
<dd>Averages a sequence of scattering data.</dd>
<dt>sum:</dt>
<dd>Takes the sum of a sequence of scattering data.</dd>
<dt>data:</dt>
<dd>Simply outputs the data in a cell array.</dd>
</dl>
</div></blockquote>
<dl class="docutils">
<dt>Scanning modes:</dt>
<dd><p class="first">Several raster scanning modes are possible:</p>
<blockquote class="last">
<div><ol class="arabic">
<li><p class="first">horizontal &lt;horz&gt; (default):</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="o">*==================</span><span class="p">=</span><span class="o">&gt;</span>
<span class="o">====================&gt;</span>
<span class="o">========&gt;</span><span class="c">...</span>
</pre></div>
</div>
</li>
<li><p class="first">horizontal, alternating &lt;horzalt&gt;:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="o">*==================</span><span class="p">=</span><span class="n">v</span>
<span class="n">v</span><span class="o">==================</span><span class="p">=</span><span class="o">&lt;</span>
<span class="o">&gt;======</span><span class="p">=</span><span class="o">&gt;</span><span class="c">...</span>
</pre></div>
</div>
</li>
<li><p class="first">vertical &lt;vert&gt;:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="o">*</span> <span class="o">|</span> <span class="o">|</span> <span class="o">|</span> <span class="n">V</span>
<span class="o">|</span> <span class="o">|</span> <span class="o">|</span> <span class="o">|</span> <span class="o">|</span>
<span class="o">|</span> <span class="o">|</span> <span class="o">|</span> <span class="o">|</span> <span class="p">.</span>
<span class="n">V</span> <span class="n">V</span> <span class="n">V</span> <span class="n">V</span> <span class="p">.</span>
</pre></div>
</div>
</li>
<li><p class="first">vertical,alternating &lt;vertalt&gt;:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="o">*</span> <span class="o">&gt;</span> <span class="n">v</span> <span class="o">&gt;</span> <span class="n">v</span>
<span class="o">|</span> <span class="o">|</span> <span class="o">|</span> <span class="o">|</span> <span class="p">.</span>
<span class="o">|</span> <span class="o">|</span> <span class="o">|</span> <span class="o">|</span> <span class="p">.</span>
<span class="o">&gt;</span> <span class="n">A</span> <span class="o">&gt;</span> <span class="n">A</span> <span class="p">.</span>
</pre></div>
</div>
</li>
</ol>
</div></blockquote>
</dd>
<dt>Output arguments:</dt>
<dd><dl class="first last docutils">
<dt>Result:</dt>
<dd><div class="first line-block">
<div class="line">struct containing the results for each method.</div>
<div class="line">Syntax: struct_name.method_name.method_results</div>
</div>
<p>Current options:</p>
<blockquote>
<div><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">data:</th><td class="field-body"><p class="first">processed data stack</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">maxProjection:</th><td class="field-body"><p class="first">maximum projection</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">mp:</th><td class="field-body"><p class="first">same as maxProjection</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">crystal:</th><td class="field-body"><p class="first">crystal map</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">devel:</th><td class="field-body"></td>
</tr>
<tr class="field-even field"><th class="field-name">dpc:</th><td class="field-body"><dl class="first docutils">
<dt>dpcx</dt>
<dd><p class="first last">(differential phase contrast,
horizontal)</p>
</dd>
<dt>dpcy</dt>
<dd><p class="first last">(differential phase contrast,
vertical)</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">stxm:</th><td class="field-body"><p class="first">df
(darkfield)</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">pca:</th><td class="field-body"><dl class="first docutils">
<dt>w</dt>
<dd><p class="first last">(anisotropy)</p>
</dd>
<dt>angle</dt>
<dd><p class="first last">(orientation of the scattering)</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">fluo:</th><td class="field-body"></td>
</tr>
<tr class="field-even field"><th class="field-name">avg:</th><td class="field-body"></td>
</tr>
<tr class="field-odd field"><th class="field-name">sum:</th><td class="field-body"></td>
</tr>
<tr class="field-even field"><th class="field-name">rotate:</th><td class="field-body"></td>
</tr>
<tr class="field-odd field"><th class="field-name">symmetry:</th><td class="field-body"><p class="first">Ln</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">b1d:</th><td class="field-body"><dl class="first docutils">
<dt>dat_1d</dt>
<dd><p class="first last">(azimuthally averaged intensities)</p>
</dd>
<dt>qr</dt>
<dd><p class="first last">(radial axis)</p>
</dd>
<dt>error</dt>
<dd><p class="first last">(error metric, L2 norm)</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">pyfai:</th><td class="field-body"><dl class="first last docutils">
<dt>dat_1d</dt>
<dd><p class="first last">(azimuthally averaged intensities)</p>
</dd>
<dt>r</dt>
<dd><p class="first last">(radial axis)</p>
</dd>
<dt>error</dt>
<dd><p class="first last">(error metric, L2 norm)</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</div></blockquote>
<div class="last line-block">
<div class="line">Note, that the output structure can be split into</div>
<div class="line">variables using the helper function</div>
<div class="line">split_struct(). This should improve readability</div>
<div class="line">of the code.</div>
</div>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="&#64;nanodiffraction.nanodiffraction.around_y">
<code class="descname">around_y</code><span class="sig-paren">(</span><em>pixel</em><span class="sig-paren">)</span><a class="headerlink" href="#@nanodiffraction.nanodiffraction.around_y" title="Permalink to this definition">¶</a></dt>
<dd><p>AROUND_Y  Returns a two-element array with a lower and upper
bound centered around the horizontal primary beam position.</p>
<blockquote>
<div><code class="docutils literal notranslate"><span class="pre">roi</span> <span class="pre">=</span> <span class="pre">around_y(pixel)</span></code></div></blockquote>
<dl class="docutils">
<dt>The following arguments are supported:</dt>
<dd><dl class="first last docutils">
<dt>pixel: []</dt>
<dd>Description.</dd>
</dl>
</dd>
</dl>
<p class="rubric">Example</p>
<p>See the following example for help:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">n</span> <span class="p">=</span> <span class="n">nanodiffraction</span><span class="p">();</span>
<span class="c">...</span>
<span class="n">n</span><span class="p">.</span><span class="n">set_roi_and_binning</span><span class="p">(</span><span class="s">&#39;roi&#39;</span><span class="p">,</span><span class="s">&#39;on&#39;</span><span class="p">,</span><span class="c">...</span>
    <span class="s">&#39;roiY&#39;</span><span class="p">,</span><span class="n">n</span><span class="p">.</span><span class="n">around_y</span><span class="p">(</span><span class="mi">150</span><span class="p">),</span><span class="c">...);</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Output arguments:</dt>
<dd><dl class="first last docutils">
<dt>roi:</dt>
<dd>Description.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="&#64;nanodiffraction.nanodiffraction.around_z">
<code class="descname">around_z</code><span class="sig-paren">(</span><em>pixel</em><span class="sig-paren">)</span><a class="headerlink" href="#@nanodiffraction.nanodiffraction.around_z" title="Permalink to this definition">¶</a></dt>
<dd><p>AROUND_Z  Returns a two-element array with a lower and upper
bound centered around the vertical primary beam position.</p>
<blockquote>
<div><code class="docutils literal notranslate"><span class="pre">roi</span> <span class="pre">=</span> <span class="pre">around_z(pixel)</span></code></div></blockquote>
<dl class="docutils">
<dt>The following arguments are supported:</dt>
<dd><dl class="first last docutils">
<dt>pixel: []</dt>
<dd>Description.</dd>
</dl>
</dd>
</dl>
<p class="rubric">Example</p>
<p>See the following example for help:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">n</span> <span class="p">=</span> <span class="n">nanodiffraction</span><span class="p">();</span>
<span class="c">...</span>
<span class="n">n</span><span class="p">.</span><span class="n">set_roi_and_binning</span><span class="p">(</span><span class="s">&#39;roi&#39;</span><span class="p">,</span><span class="s">&#39;on&#39;</span><span class="p">,</span><span class="c">...</span>
    <span class="s">&#39;roiY&#39;</span><span class="p">,</span><span class="n">n</span><span class="p">.</span><span class="n">around_y</span><span class="p">(</span><span class="mi">150</span><span class="p">),</span><span class="c">...</span>
    <span class="s">&#39;roiZ&#39;</span><span class="p">,</span><span class="n">n</span><span class="p">.</span><span class="n">around_z</span><span class="p">(</span><span class="mi">150</span><span class="p">));</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Output arguments:</dt>
<dd><dl class="first last docutils">
<dt>roi:</dt>
<dd>Description.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="&#64;nanodiffraction.nanodiffraction.attach">
<code class="descname">attach</code><span class="sig-paren">(</span><em>files_handle</em><span class="sig-paren">)</span><a class="headerlink" href="#@nanodiffraction.nanodiffraction.attach" title="Permalink to this definition">¶</a></dt>
<dd><p>ATTACH  Attaches a files-module to this class.</p>
<blockquote>
<div><code class="docutils literal notranslate"><span class="pre">attach(files_handle)</span></code></div></blockquote>
<dl class="docutils">
<dt>The following arguments are supported:</dt>
<dd><dl class="first last docutils">
<dt>files_handle: [] (required)</dt>
<dd>Handle to a files-module.</dd>
</dl>
</dd>
</dl>
<p class="rubric">Example</p>
<p>See the following example for help:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">e</span> <span class="p">=</span> <span class="n">nanodiffraction</span><span class="p">(</span><span class="c">...);</span>
<span class="n">f</span> <span class="p">=</span> <span class="n">files</span><span class="p">(</span><span class="c">...);</span>
<span class="n">e</span><span class="p">.</span><span class="n">attach</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Output arguments:</dt>
<dd>This function does not return any arguments.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="&#64;nanodiffraction.nanodiffraction.azimuthal_mask">
<code class="descname">azimuthal_mask</code><span class="sig-paren">(</span><em>phi1</em>, <em>phi2</em><span class="sig-paren">)</span><a class="headerlink" href="#@nanodiffraction.nanodiffraction.azimuthal_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>AZIMUTHAL_MASK  defines an azimuthal mask (e.g. useful for
PCA analysis). This function creates a circular or
ring-shaped mask. Note, that the angles in degrees follow
the mathematical convention (counter-clockwise and 0° at
3 o’clock).</p>
<blockquote>
<div><code class="docutils literal notranslate"><span class="pre">mask</span> <span class="pre">=</span> <span class="pre">azimuthal_mask(phi1,phi2)</span></code></div></blockquote>
<dl class="docutils">
<dt>The following parameters are accepted:</dt>
<dd><dl class="first last docutils">
<dt>phi1:: [65] (optional)</dt>
<dd>Start angle in degrees.</dd>
<dt>phi2: [232] (optional)</dt>
<dd>End angle in degrees</dd>
</dl>
</dd>
</dl>
<p class="rubric">Example</p>
<p>See the following example for help:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">e</span> <span class="p">=</span> <span class="n">nanodiffraction</span><span class="p">();</span>
 <span class="n">mask</span> <span class="p">=</span> <span class="n">e</span><span class="p">.</span><span class="n">azimuthal_mask</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span><span class="mi">45</span><span class="p">);</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Output arguments:</dt>
<dd><dl class="first last docutils">
<dt>mask:</dt>
<dd>A two-dimensional logical azimuthal mask.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="&#64;nanodiffraction.nanodiffraction.azimuthal_spread">
<code class="descname">azimuthal_spread</code><span class="sig-paren">(</span><em>dat_1d</em>, <em>qr</em><span class="sig-paren">)</span><a class="headerlink" href="#@nanodiffraction.nanodiffraction.azimuthal_spread" title="Permalink to this definition">¶</a></dt>
<dd><p>AZIMUTHAL_SPREAD  takes a one-dimensional intensity profile
and the corresponding q_r position as input and
reinterpolates the data onto the two-dimensional detector
grid. This can be useful when semi-transparent objects such
as a beamstop shall be corrected for.</p>
<blockquote>
<div><code class="docutils literal notranslate"><span class="pre">image</span> <span class="pre">=</span> <span class="pre">azimuthal_spread(data_1d,qr)</span></code></div></blockquote>
<dl class="docutils">
<dt>The following arguments are supported:</dt>
<dd><dl class="first last docutils">
<dt>dat_1d: [] (required)</dt>
<dd>One-dimensional structure factor as obtained e.g.
from any azimuthal integration routine such as b1d
or pyfai.</dd>
<dt>qr: [] (required)</dt>
<dd>Corresponding x-axis, given in units of the radial
wavevector transfer qr (reciprocal nanometers).</dd>
</dl>
</dd>
</dl>
<p class="rubric">Example</p>
<p>See the following example for help:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span> <span class="n">e</span> <span class="p">=</span> <span class="n">nanodiffraction</span><span class="p">(</span><span class="o">&lt;</span><span class="n">some</span> <span class="n">settings</span><span class="o">&gt;</span><span class="p">);</span>
<span class="n">e</span><span class="p">.</span><span class="n">set_scan_info</span><span class="p">(</span><span class="s">&#39;SNy&#39;</span><span class="p">,</span><span class="mi">512</span><span class="p">,</span><span class="s">&#39;SNz&#39;</span><span class="p">,</span><span class="mi">651</span><span class="p">);</span>
 <span class="n">mask</span>    <span class="p">=</span> <span class="n">e</span><span class="p">.</span><span class="n">masks</span> <span class="o">|</span> <span class="n">e</span><span class="p">.</span><span class="n">azimuthal_mask</span><span class="p">(</span><span class="s">&#39;phi1&#39;</span><span class="p">,</span><span class="o">-</span><span class="mi">20</span><span class="p">,</span><span class="s">&#39;phi2&#39;</span><span class="p">,</span><span class="mi">20</span><span class="p">);</span>
 <span class="n">bs</span>      <span class="p">=</span> <span class="n">e</span><span class="p">.</span><span class="n">analyze_scan</span><span class="p">(</span><span class="s">&#39;method&#39;</span><span class="p">,</span><span class="s">&#39;average&#39;</span><span class="p">,</span><span class="s">&#39;zCrop&#39;</span><span class="p">,[</span><span class="mi">1</span> <span class="mi">2</span><span class="p">],</span><span class="s">&#39;yCrop&#39;</span><span class="p">,[</span><span class="mi">2</span> <span class="mi">1079</span><span class="p">]);</span>
 <span class="n">rad_bgr</span> <span class="p">=</span> <span class="n">b1d</span><span class="p">(</span><span class="n">bs</span><span class="p">.</span><span class="n">avg</span><span class="p">,</span><span class="n">mask</span><span class="p">,[],</span><span class="n">e</span><span class="p">.</span><span class="n">qr</span><span class="p">,</span><span class="mi">512</span><span class="p">);</span>
 <span class="n">image</span>   <span class="p">=</span> <span class="n">e</span><span class="p">.</span><span class="n">azimuthal_spread</span><span class="p">(</span><span class="n">rad_bgr</span><span class="p">.</span><span class="n">dat_1d</span><span class="p">,</span><span class="n">rad_bgr</span><span class="p">.</span><span class="n">qr</span><span class="p">);</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Output arguments:</dt>
<dd><dl class="first last docutils">
<dt>image:</dt>
<dd>Filtered image.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="&#64;nanodiffraction.nanodiffraction.calculate_composite">
<code class="descname">calculate_composite</code><span class="sig-paren">(</span><em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@nanodiffraction.nanodiffraction.calculate_composite" title="Permalink to this definition">¶</a></dt>
<dd><p>CALCULATE_COMPOSITE  calculates a composite image from a
series of diffraction patterns.</p>
<blockquote>
<div><cite>[composite, parameters] = calculate_composite(options)`</cite></div></blockquote>
<dl class="docutils">
<dt>The following arguments are supported:</dt>
<dd><dl class="first last docutils">
<dt>options:: [see default values below] (optional)</dt>
<dd><p class="first">Structure that can contain the following fields. Note,
that all fields are optional. Default values that are
otherwise used are as usual given in angle brackets:</p>
<dl class="last docutils">
<dt>yCrop: [1 obj.scan.SNy]</dt>
<dd>Description.</dd>
<dt>zCrop: [1 obj.scan.SNz]</dt>
<dd>Description.</dd>
<dt>ySkip: [1]</dt>
<dd>Description.</dd>
<dt>zSkip: [1]</dt>
<dd>Description.</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Example</p>
<p>See the following example for help:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">e</span> <span class="p">=</span> <span class="n">nanodiffraction</span><span class="p">(</span><span class="o">&lt;</span><span class="n">some</span> <span class="n">settings</span> <span class="n">here</span><span class="o">&gt;</span><span class="p">);</span>
<span class="n">e</span><span class="p">.</span><span class="n">set_scan_info</span><span class="p">(</span><span class="o">&lt;</span><span class="n">some</span> <span class="n">settings</span> <span class="n">here</span><span class="o">&gt;</span><span class="p">);</span>
<span class="p">[</span><span class="n">comp</span><span class="p">,</span><span class="n">p</span><span class="p">]</span> <span class="p">=</span> <span class="n">e</span><span class="p">.</span><span class="n">calculate_composite</span><span class="p">(</span><span class="c">...</span>
            <span class="n">struct</span><span class="p">(</span><span class="s">&#39;ySkip&#39;</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="s">&#39;zSkip&#39;</span><span class="p">,</span><span class="mi">4</span><span class="p">));</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Output arguments:</dt>
<dd><dl class="first last docutils">
<dt>composite:</dt>
<dd>Processed composite matrix.</dd>
<dt>parameters:</dt>
<dd>Parameters used to combine the input data. Is used
in combination with (display_class).composite. See
help display.composite for more information</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="&#64;nanodiffraction.nanodiffraction.clicktool">
<code class="descname">clicktool</code><span class="sig-paren">(</span><em>vis</em>, <em>map</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@nanodiffraction.nanodiffraction.clicktool" title="Permalink to this definition">¶</a></dt>
<dd><p>CLICKTOOL  Once a parameter map of the data is shown in the
active figure, clicktool can be called and a diffraction
pattern or 1d saxs curves are loaded, based on the scan point
that was clicked on.</p>
<blockquote>
<div><code class="docutils literal notranslate"><span class="pre">clicktool(vis,map,optional)</span></code></div></blockquote>
<dl class="docutils">
<dt>The following arguments are supported:</dt>
<dd><dl class="first last docutils">
<dt>vis: [] (required)</dt>
<dd>visualization tool (required).</dd>
<dt>map: [] (required)</dt>
<dd>Depending on the crop and skip parameters used
during the last scan analysis, the click location
might have to be mapped onto the corresponding
position in the scan. It map is empty, 1x1 mapping
will be used, otherwise, map has to be an array
containing the following parameters
[yCrop zCrop ySkip zSkip]</dd>
<dt>optional: [] (optional)</dt>
<dd>If no optional parameters are given, then a
diffraction pattern will loaded, otherwise, an
arbitrary number of structs can be given, containing
an m:SNy:SNz data block (m: length of single saxs
curve). The struct has to contain a data block and a
scale, hence, should be passed e.g. as
struct(‘data’,data,’scale’,sc)</dd>
</dl>
</dd>
</dl>
<p class="rubric">Example</p>
<p>See the following example for help:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">Example</span> <span class="n">missing</span><span class="p">.</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Output arguments:</dt>
<dd>This function does not return any arguments.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="&#64;nanodiffraction.nanodiffraction.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#@nanodiffraction.nanodiffraction.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>COPY  Makes a copy of a handle object. This keeps track of
all the given parameters so that multiple instances of a
display module can be used.</p>
<blockquote>
<div><code class="docutils literal notranslate"><span class="pre">new_instance</span> <span class="pre">=</span> <span class="pre">copy(nanodiffraction_object)</span></code></div></blockquote>
<dl class="docutils">
<dt>The following arguments are supported:</dt>
<dd><dl class="first last docutils">
<dt>nanodiffraction_object: [] (required)</dt>
<dd>This function requires a nanodiffraction object that
should be copied.</dd>
</dl>
</dd>
</dl>
<p class="rubric">Example</p>
<p>See the following example for help:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">e_generic</span> <span class="p">=</span> <span class="n">nanodiffraction</span><span class="p">();</span>
<span class="n">e_saxsdata</span> <span class="p">=</span> <span class="n">copy</span><span class="p">(</span><span class="n">e_generic</span><span class="p">);</span>
<span class="n">e_waxsdata</span> <span class="p">=</span> <span class="n">copy</span><span class="p">(</span><span class="n">e_generic</span><span class="p">);</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Output arguments:</dt>
<dd><dl class="first last docutils">
<dt>new_instance:</dt>
<dd>A copy of the initial
nanodiffraction_object.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="&#64;nanodiffraction.nanodiffraction.get_index">
<code class="descname">get_index</code><span class="sig-paren">(</span><em>q</em>, <em>pos</em><span class="sig-paren">)</span><a class="headerlink" href="#@nanodiffraction.nanodiffraction.get_index" title="Permalink to this definition">¶</a></dt>
<dd><p>GET_INDEX  Calculates pixel coordinate in pixels given a Q
value.</p>
<blockquote>
<div><code class="docutils literal notranslate"><span class="pre">out</span> <span class="pre">=</span> <span class="pre">get_index(q,position)</span></code></div></blockquote>
<dl class="docutils">
<dt>The following arguments are supported:</dt>
<dd><dl class="first last docutils">
<dt>q: [] (required)</dt>
<dd>q-axis, where q is the reciprocal wavevector coordinate
in units of reciprocal nanometers.</dd>
<dt>position: [] (required)</dt>
<dd>Query position.</dd>
</dl>
</dd>
</dl>
<p class="rubric">Example</p>
<p>See the following example for help:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">Example</span> <span class="n">missing</span><span class="p">.</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Output arguments:</dt>
<dd><dl class="first last docutils">
<dt>out:</dt>
<dd>Linear index of the nearest matching element in the
q-axis.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="&#64;nanodiffraction.nanodiffraction.get_location_in_frame">
<code class="descname">get_location_in_frame</code><span class="sig-paren">(</span><em>y</em>, <em>z</em>, <em>sn</em>, <em>stitch</em><span class="sig-paren">)</span><a class="headerlink" href="#@nanodiffraction.nanodiffraction.get_location_in_frame" title="Permalink to this definition">¶</a></dt>
<dd><p>GET_LOCATION_IN_FRAME  Calculates the scan position within a
frame based on the location in the stitched image.</p>
<blockquote>
<div><code class="docutils literal notranslate"><span class="pre">result</span> <span class="pre">=</span> <span class="pre">get_location_in_frame(y,z,sn,stitch);</span></code></div></blockquote>
<dl class="docutils">
<dt>The following arguments are supported:</dt>
<dd><dl class="first last docutils">
<dt>y: [] (required)</dt>
<dd>Description.</dd>
<dt>z: [] (required)</dt>
<dd>Description.</dd>
<dt>sn: [] (required)</dt>
<dd>Description.</dd>
<dt>stitch: [] (required)</dt>
<dd>Description.</dd>
</dl>
</dd>
</dl>
<p class="rubric">Example</p>
<p>See the following example for help:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">Example</span> <span class="n">missing</span><span class="p">.</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Output arguments:</dt>
<dd><dl class="first last docutils">
<dt>result:</dt>
<dd><p class="first">Structure containing the following fields:</p>
<table class="last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">linind:</th><td class="field-body">Description.</td>
</tr>
<tr class="field-even field"><th class="field-name">linfield:</th><td class="field-body">Description.</td>
</tr>
<tr class="field-odd field"><th class="field-name">field:</th><td class="field-body">Description.</td>
</tr>
<tr class="field-even field"><th class="field-name">ind:</th><td class="field-body">Description.</td>
</tr>
</tbody>
</table>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="&#64;nanodiffraction.nanodiffraction.get_parameters">
<code class="descname">get_parameters</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#@nanodiffraction.nanodiffraction.get_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>GET_PARAMETERS  Returns the experimental parameters stored in
the nanodiffraction class. Note, that helper functions and
links to other classes are not returned.</p>
<blockquote>
<div>result = get_parameters()</div></blockquote>
<dl class="docutils">
<dt>The following arguments are supported:</dt>
<dd>This function does not require any arguments.</dd>
</dl>
<p class="rubric">Example</p>
<p>e = nanodiffraction();
p = e.get_parameters()</p>
<dl class="docutils">
<dt>Output arguments:</dt>
<dd><dl class="first last docutils">
<dt>result:: Structure containing all experimental parameters</dt>
<dd>stored in this instance of the nanodiffraction class.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="&#64;nanodiffraction.nanodiffraction.heal">
<code class="descname">heal</code><span class="sig-paren">(</span><em>data</em>, <em>mask</em><span class="sig-paren">)</span><a class="headerlink" href="#@nanodiffraction.nanodiffraction.heal" title="Permalink to this definition">¶</a></dt>
<dd><p>HEAL  uses make_mask_symmetric to find the correct mapping
from valid to invalid pixels. Takes in an n x m data matrix
and an n x m logical mask (1: corrupt pixel, 0: otherwise)
and mirrors data that is lost due to e.g. modular gaps from
the point-symmetric position in the data. This function was
inspired by the article ‘’ by
Liu et al., IUCrJ 2017, Vol. 4, Issue 4, pp. 455 - 465.</p>
<blockquote>
<div><code class="docutils literal notranslate"><span class="pre">healed</span> <span class="pre">=</span> <span class="pre">heal(data,mask)</span></code></div></blockquote>
<dl class="docutils">
<dt>The following arguments are supported:</dt>
<dd><dl class="first last docutils">
<dt>data: [] (required)</dt>
<dd>An n x m data matrix.</dd>
<dt>mask: [] (required)</dt>
<dd>An n x m logical matrix indicating bad pixels.
1: invalid pixel, 0: valid pixel.</dd>
</dl>
</dd>
</dl>
<p class="rubric">Example</p>
<p>See the following example for help:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">e</span> <span class="p">=</span> <span class="n">nanodiffraction</span><span class="p">();</span>
<span class="n">frame</span> <span class="p">=</span> <span class="n">e</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="n">mask</span> <span class="p">=</span> <span class="p">(</span><span class="n">frame</span> <span class="o">==</span> <span class="n">max</span><span class="p">(</span><span class="n">frame</span><span class="p">(:)));</span>
<span class="n">healed_frame</span> <span class="p">=</span> <span class="n">e</span><span class="p">.</span><span class="n">heal</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span><span class="n">mask</span><span class="p">);</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Output arguments:</dt>
<dd><dl class="first last docutils">
<dt>healed:</dt>
<dd>healed scattering pattern.</dd>
<dt>il:</dt>
<dd>index list (mapping from valid to invalid pixels)</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="&#64;nanodiffraction.nanodiffraction.helper">
<code class="descname">helper</code><em class="property"> = u'struct'</em><a class="headerlink" href="#@nanodiffraction.nanodiffraction.helper" title="Permalink to this definition">¶</a></dt>
<dd><p>holds helper functions</p>
</dd></dl>

<dl class="method">
<dt id="&#64;nanodiffraction.nanodiffraction.ind2sub">
<code class="descname">ind2sub</code><span class="sig-paren">(</span><em>ind</em>, <em>sny</em><span class="sig-paren">)</span><a class="headerlink" href="#@nanodiffraction.nanodiffraction.ind2sub" title="Permalink to this definition">¶</a></dt>
<dd><p>IND2SUB  calculates the row and column index based on the
linear index in the current scan.</p>
<blockquote>
<div><code class="docutils literal notranslate"><span class="pre">[row,col]</span> <span class="pre">=</span> <span class="pre">ind2sub(linear_index,</span> <span class="pre">sny)</span></code></div></blockquote>
<dl class="docutils">
<dt>The following arguments are supported:</dt>
<dd><dl class="first last docutils">
<dt>linear_index: [] (required)</dt>
<dd>Linear index. The first index in the scan is 1.</dd>
<dt>sny: [] (required)</dt>
<dd>Number of scan points per line (fast axis).</dd>
</dl>
</dd>
</dl>
<p class="rubric">Example</p>
<p>See the following example for help:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">Example</span> <span class="n">missing</span><span class="p">.</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Output arguments:</dt>
<dd><dl class="first last docutils">
<dt>row:</dt>
<dd>Row index in scan.</dd>
<dt>col:</dt>
<dd>Column index in scan.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="&#64;nanodiffraction.nanodiffraction.make_mask_symmetric">
<code class="descname">make_mask_symmetric</code><span class="sig-paren">(</span><em>mask</em><span class="sig-paren">)</span><a class="headerlink" href="#@nanodiffraction.nanodiffraction.make_mask_symmetric" title="Permalink to this definition">¶</a></dt>
<dd><p>MAKE_MASK_SYMMETRIC  reads in a mask and then rotates the
mask 180 degrees around the primary beam position. The
rotated mask is compared to the unrotated mask and logically
combined (&amp;).</p>
<blockquote>
<div><code class="docutils literal notranslate"><span class="pre">[symm_mask,</span> <span class="pre">mask_orig,</span> <span class="pre">mask,</span> <span class="pre">good_zero,</span> <span class="pre">bad_zero]</span> <span class="pre">=</span> <span class="pre">make_mask_symmetric(mask)</span></code></div></blockquote>
<dl class="docutils">
<dt>The following arguments are supported:</dt>
<dd><dl class="first last docutils">
<dt>mask: []  (required)</dt>
<dd>A valid logical detector mask.</dd>
</dl>
</dd>
</dl>
<p class="rubric">Example</p>
<p>See the following example for help:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">Example</span> <span class="n">missing</span><span class="p">.</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Output arguments:</dt>
<dd><dl class="first last docutils">
<dt>symm_mask:</dt>
<dd>Description missing.</dd>
<dt>mask_orig:</dt>
<dd>Description missing.</dd>
<dt>mask:</dt>
<dd>Description missing.</dd>
<dt>good_zero:</dt>
<dd>Description missing.</dd>
<dt>bad_zero:</dt>
<dd>Description missing.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="&#64;nanodiffraction.nanodiffraction.moment_from_selection">
<code class="descname">moment_from_selection</code><span class="sig-paren">(</span><em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@nanodiffraction.nanodiffraction.moment_from_selection" title="Permalink to this definition">¶</a></dt>
<dd><p>MOMENT_FROM_SELECTION  In an active figure, a roi can be
selected and the mean, standard deviation, variance and the
median can be obtained.</p>
<blockquote>
<div><code class="docutils literal notranslate"><span class="pre">parameter</span> <span class="pre">=</span> <span class="pre">moment_from_selection(opts)</span></code></div></blockquote>
<dl class="docutils">
<dt>The following arguments are supported:</dt>
<dd><dl class="first last docutils">
<dt>opts: [‘mean’]  (optional)</dt>
<dd><p class="first">Moment that should be calculated. By default, the
mean will be calculated if opts is not set.</p>
<div class="last line-block">
<div class="line">The following options are available:</div>
<div class="line">‘mean’,’std’,’var’,’median’</div>
</div>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Example</p>
<p>See the following example for help:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">Example</span> <span class="n">missing</span><span class="p">.</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Output arguments:</dt>
<dd><dl class="first last docutils">
<dt>parameters:</dt>
<dd>Description missing.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="&#64;nanodiffraction.nanodiffraction.n_of_q">
<code class="descname">n_of_q</code><span class="sig-paren">(</span><em>q</em><span class="sig-paren">)</span><a class="headerlink" href="#@nanodiffraction.nanodiffraction.n_of_q" title="Permalink to this definition">¶</a></dt>
<dd><p>N_OF_Q  Calculates pixel coordinate in pixels given a Q
value. This function cannot be defined as an anonymous
function, because pixelsize might in fact not be constant
(and the other constants in some rare occasions as well)</p>
<blockquote>
<div><code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">=</span> <span class="pre">n_of_q(q)</span></code></div></blockquote>
<dl class="docutils">
<dt>The following arguments are supported:</dt>
<dd><dl class="first last docutils">
<dt>q: [] (required)</dt>
<dd>Coordinate in units of the reciprocal wavevector
(inverse nanometers)</dd>
</dl>
</dd>
</dl>
<p class="rubric">Example</p>
<p>See the following example for help:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">Example</span> <span class="n">missing</span><span class="p">.</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Output arguments:</dt>
<dd><dl class="first last docutils">
<dt>n:</dt>
<dd>Coordinate in units of detector pixels.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="&#64;nanodiffraction.nanodiffraction.process">
<code class="descname">process</code><span class="sig-paren">(</span><em>dat</em><span class="sig-paren">)</span><a class="headerlink" href="#@nanodiffraction.nanodiffraction.process" title="Permalink to this definition">¶</a></dt>
<dd><p>PROCESS  Used for processing detector images. The frame
will be adapted to the current setting of a detector ROI and
binning factors.</p>
<blockquote>
<div><code class="docutils literal notranslate"><span class="pre">processed_data</span> <span class="pre">=</span> <span class="pre">process(data)</span></code></div></blockquote>
<dl class="docutils">
<dt>The following arguments are supported:</dt>
<dd><dl class="first last docutils">
<dt>data: [] (required)</dt>
<dd>A two-dimensional detector image. The dimensions of the
array should correspond to the detector size.</dd>
</dl>
</dd>
</dl>
<p class="rubric">Example</p>
<p>See the following example for help:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">e</span> <span class="p">=</span> <span class="n">nanodiffraction</span><span class="p">();</span>
<span class="n">frame</span> <span class="p">=</span> <span class="n">e</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="n">e</span><span class="p">.</span><span class="n">set_roi_and_binning</span><span class="p">(</span><span class="s">&#39;binning&#39;</span><span class="p">,</span><span class="s">&#39;on&#39;</span><span class="p">,</span><span class="s">&#39;binY&#39;</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="s">&#39;binZ&#39;</span><span class="p">,</span><span class="mi">4</span><span class="p">);</span>
<span class="n">processed_frame</span> <span class="p">=</span> <span class="n">e</span><span class="p">.</span><span class="n">process</span><span class="p">(</span><span class="n">frame</span><span class="p">);</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Output arguments:</dt>
<dd><dl class="first last docutils">
<dt>processed_data:</dt>
<dd>The cropped and rebinned detector image.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="&#64;nanodiffraction.nanodiffraction.process_mask">
<code class="descname">process_mask</code><span class="sig-paren">(</span><em>mask</em><span class="sig-paren">)</span><a class="headerlink" href="#@nanodiffraction.nanodiffraction.process_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>PROCESS_MASK  Used for processing logical masks. The mask
will be adapted to the current setting of a detector ROI and
binning factors.</p>
<blockquote>
<div><code class="docutils literal notranslate"><span class="pre">processed_mask</span> <span class="pre">=</span> <span class="pre">process_mask(mask)</span></code></div></blockquote>
<dl class="docutils">
<dt>The following arguments are supported:</dt>
<dd><dl class="first last docutils">
<dt>mask: [] (required)</dt>
<dd>A two-dimensional mask. The dimensions of the array
should correspond to the detector size.</dd>
</dl>
</dd>
</dl>
<p class="rubric">Example</p>
<p>See the following example for help:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">e</span> <span class="p">=</span> <span class="n">nanodiffraction</span><span class="p">();</span>
<span class="n">mask</span> <span class="p">=</span> <span class="n">e</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1000</span><span class="p">;</span>
<span class="n">e</span><span class="p">.</span><span class="n">set_roi_and_binning</span><span class="p">(</span><span class="s">&#39;binning&#39;</span><span class="p">,</span><span class="s">&#39;on&#39;</span><span class="p">,</span><span class="s">&#39;binY&#39;</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="s">&#39;binZ&#39;</span><span class="p">,</span><span class="mi">4</span><span class="p">);</span>
<span class="n">new_mask</span> <span class="p">=</span> <span class="n">e</span><span class="p">.</span><span class="n">process_mask</span><span class="p">(</span><span class="n">mask</span><span class="p">);</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Output arguments:</dt>
<dd><dl class="first last docutils">
<dt>processed_mask:</dt>
<dd>The cropped and rebinned logical mask.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="&#64;nanodiffraction.nanodiffraction.q_of_n">
<code class="descname">q_of_n</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#@nanodiffraction.nanodiffraction.q_of_n" title="Permalink to this definition">¶</a></dt>
<dd><p>Q_OF_N  Calculates Q coordinate in [nm^-1] given a pixel
coordinate. This function cannot be defined as an anonymous
function, because pixelsize might in fact not be constant
(and the other constants in some rare occasions as well)</p>
<blockquote>
<div><code class="docutils literal notranslate"><span class="pre">q</span> <span class="pre">=</span> <span class="pre">q_of_n(n)</span></code></div></blockquote>
<dl class="docutils">
<dt>The following arguments are supported:</dt>
<dd><dl class="first last docutils">
<dt>n: [] (required)</dt>
<dd>Coordinate in units of detector pixels</dd>
</dl>
</dd>
</dl>
<p class="rubric">Example</p>
<p>See the following example for help:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">Example</span> <span class="n">missing</span><span class="p">.</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Output arguments:</dt>
<dd><dl class="first last docutils">
<dt>q:</dt>
<dd>Coordinate in units of the radial wavevector transfer
(reciprocal nanometers).</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="&#64;nanodiffraction.nanodiffraction.qr_tilt">
<code class="descname">qr_tilt</code><span class="sig-paren">(</span><em>alpha</em>, <em>beta</em>, <em>gamma</em><span class="sig-paren">)</span><a class="headerlink" href="#@nanodiffraction.nanodiffraction.qr_tilt" title="Permalink to this definition">¶</a></dt>
<dd><p>QR_TILT  Description missing.</p>
<blockquote>
<div><code class="docutils literal notranslate"><span class="pre">[qr,x,y,z]</span> <span class="pre">=</span> <span class="pre">qr_tilt(alpha,</span> <span class="pre">beta,</span> <span class="pre">gamma)</span></code></div></blockquote>
<dl class="docutils">
<dt>The following arguments are supported:</dt>
<dd><dl class="first last docutils">
<dt>alpha: []</dt>
<dd>Tilt angle of the detector in degrees.</dd>
<dt>beta: []</dt>
<dd>Tilt angle of the detector in degrees.</dd>
<dt>gamma: []</dt>
<dd>Tilt angle of the detector in degrees.</dd>
</dl>
</dd>
</dl>
<p class="rubric">Example</p>
<p>See the following example for help:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">Example</span> <span class="n">missing</span><span class="p">.</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Output arguments:</dt>
<dd><dl class="first last docutils">
<dt>qr:</dt>
<dd>Corrected radial wavevector transfer detector
coordinates, based on the detector tilt angles.</dd>
<dt>x:</dt>
<dd>Corrected x-position of the detector pixel
coordinates, based on the detector tilt angles.</dd>
<dt>y:</dt>
<dd>Corrected y-position of the detector pixel
coordinates, based on the detector tilt angles.</dd>
<dt>z:</dt>
<dd>Corrected z-position of the detector pixel
coordinates, based on the detector tilt angles.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="&#64;nanodiffraction.nanodiffraction.radial_mask">
<code class="descname">radial_mask</code><span class="sig-paren">(</span><em>r1</em>, <em>r2</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@nanodiffraction.nanodiffraction.radial_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>RADIAL_MASK  defines a radial mask (e.g. useful for a PCA
analysis). Creates a circular or ring-shaped mask and stores
it in (nanodiffraction_class).sels.</p>
<blockquote>
<div><code class="docutils literal notranslate"><span class="pre">mask</span> <span class="pre">=</span> <span class="pre">radial_mask(r1,r2,grid)</span></code></div></blockquote>
<p>The following arguments are accepted:</p>
<blockquote>
<div><dl class="docutils">
<dt>r1: [] (required)</dt>
<dd>Inner radius</dd>
<dt>r2: [] (required)</dt>
<dd>Outer radius (Inverse radius)</dd>
<dt>grid: [nanodiffraction.qr] (optional)</dt>
<dd>Two-dimensional detector coordinates.</dd>
</dl>
</div></blockquote>
<p class="rubric">Example</p>
<p>See the following example for help:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">e</span> <span class="p">=</span> <span class="n">nanodiffraction</span><span class="p">();</span>
<span class="n">mask</span> <span class="p">=</span> <span class="n">e</span><span class="p">.</span><span class="n">radial_mask</span><span class="p">(</span><span class="mf">0.2</span><span class="p">,</span><span class="mf">1.2</span><span class="p">,</span><span class="n">e</span><span class="p">.</span><span class="n">qr</span><span class="p">);</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Output arguments:</dt>
<dd><dl class="first last docutils">
<dt>mask:</dt>
<dd>A two-dimensional logical radial mask.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="&#64;nanodiffraction.nanodiffraction.read">
<code class="descname">read</code><span class="sig-paren">(</span><em>fn</em><span class="sig-paren">)</span><a class="headerlink" href="#@nanodiffraction.nanodiffraction.read" title="Permalink to this definition">¶</a></dt>
<dd><p>READ  reads data from the data module. Note, that data is not
treated in any way (binning, cropping, etc.).</p>
<blockquote>
<div><code class="docutils literal notranslate"><span class="pre">raw_data</span> <span class="pre">=</span> <span class="pre">read(fn)</span> <span class="pre">reads</span> <span class="pre">single</span> <span class="pre">frame.</span></code></div></blockquote>
<dl class="docutils">
<dt>The following arguments are supported:</dt>
<dd><dl class="first last docutils">
<dt>fn: [] (required)</dt>
<dd>Frame number (&gt;0). Note that the frame number always
identifies the frame within a scan. This should not
be confused with the file number used in the
files-module. There, the file number is associated
with a specific file within a newfile-session. For
this reason, the file number could start with 0.</dd>
</dl>
</dd>
</dl>
<p class="rubric">Example</p>
<p>See the following example for help:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">e</span> <span class="p">=</span> <span class="n">nanodiffraction</span><span class="p">();</span>
<span class="n">first_frame</span> <span class="p">=</span> <span class="n">e</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Output arguments:</dt>
<dd><dl class="first last docutils">
<dt>raw_data:</dt>
<dd>Raw detector frame.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="&#64;nanodiffraction.nanodiffraction.readm">
<code class="descname">readm</code><span class="sig-paren">(</span><em>fn</em><span class="sig-paren">)</span><a class="headerlink" href="#@nanodiffraction.nanodiffraction.readm" title="Permalink to this definition">¶</a></dt>
<dd><p>READM  reads data from data module. Note, that data is
processed using the built-in function
(nanodiffraction_class).process and the detector mask is
applied on the data frame.</p>
<blockquote>
<div><code class="docutils literal notranslate"><span class="pre">processed_data</span> <span class="pre">=</span> <span class="pre">readm(fn)</span></code></div></blockquote>
<dl class="docutils">
<dt>The following arguments are supported:</dt>
<dd><dl class="first last docutils">
<dt>fn: [] (required)</dt>
<dd>Frame number (&gt;0). Note that the frame number always
identifies the frame within a scan. This should not
be confused with the file number used in the
files-module. There, the file number is associated
with a specific file within a newfile-session. For
this reason, the file number could start with 0.</dd>
</dl>
</dd>
</dl>
<p class="rubric">Example</p>
<p>See the following example for help:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">e</span> <span class="p">=</span> <span class="n">nanodiffraction</span><span class="p">();</span>
 <span class="n">e</span><span class="p">.</span><span class="n">set_roi_and_binning</span><span class="p">(</span><span class="s">&#39;binning&#39;</span><span class="p">,</span><span class="s">&#39;on&#39;</span><span class="p">,</span><span class="s">&#39;binY&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="s">&#39;binZ&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>
 <span class="n">e</span><span class="p">.</span><span class="n">set_mask</span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1000</span><span class="p">);</span>
 <span class="n">first_frame</span> <span class="p">=</span> <span class="n">e</span><span class="p">.</span><span class="n">readm</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Output arguments:</dt>
<dd><dl class="first last docutils">
<dt>processed_data:</dt>
<dd>Processed detector frame.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="&#64;nanodiffraction.nanodiffraction.readp">
<code class="descname">readp</code><span class="sig-paren">(</span><em>fn</em><span class="sig-paren">)</span><a class="headerlink" href="#@nanodiffraction.nanodiffraction.readp" title="Permalink to this definition">¶</a></dt>
<dd><p>READP  reads data from data module. Note, that data is
processed using the built-in function
(nanodiffraction_class).process.</p>
<blockquote>
<div><code class="docutils literal notranslate"><span class="pre">processed_data</span> <span class="pre">=</span> <span class="pre">readp(fn)</span></code></div></blockquote>
<dl class="docutils">
<dt>The following arguments are supported:</dt>
<dd><dl class="first last docutils">
<dt>fn: [] (required)</dt>
<dd>Frame number (&gt;0). Note that the frame number always
identifies the frame within a scan. This should not
be confused with the file number used in the
files-module. There, the file number is associated
with a specific file within a newfile-session. For
this reason, the file number could start with 0.</dd>
</dl>
</dd>
</dl>
<p class="rubric">Example</p>
<p>See the following example for help:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">e</span> <span class="p">=</span> <span class="n">nanodiffraction</span><span class="p">();</span>
<span class="n">e</span><span class="p">.</span><span class="n">set_roi_and_binning</span><span class="p">(</span><span class="s">&#39;binning&#39;</span><span class="p">,</span><span class="s">&#39;on&#39;</span><span class="p">,</span><span class="s">&#39;binY&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="s">&#39;binZ&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>
<span class="n">first_frame</span> <span class="p">=</span> <span class="n">e</span><span class="p">.</span><span class="n">readp</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Output arguments:</dt>
<dd><dl class="first last docutils">
<dt>processed_data:</dt>
<dd>Processed detector frame.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="&#64;nanodiffraction.nanodiffraction.refresh">
<code class="descname">refresh</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#@nanodiffraction.nanodiffraction.refresh" title="Permalink to this definition">¶</a></dt>
<dd><p>REFRESH  This function is needed in case the geometry
settings change. This could happen eg. when for
some reason the detector pixel size was changed (e.g. when
binning was used) and q_r, primary beam position, etc. has to
be recalculated.</p>
<blockquote>
<div><code class="docutils literal notranslate"><span class="pre">refresh()</span></code></div></blockquote>
<dl class="docutils">
<dt>The following arguments are supported:</dt>
<dd>This function does not require any arguments.</dd>
</dl>
<p class="rubric">Example</p>
<p>See the following example for help:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">e</span> <span class="p">=</span> <span class="n">nanodiffraction</span><span class="p">();</span>
<span class="n">e</span><span class="p">.</span><span class="n">pby</span> <span class="p">=</span> <span class="mi">1000</span><span class="p">;</span> <span class="n">e</span><span class="p">.</span><span class="n">pbz</span> <span class="p">=</span> <span class="mi">1200</span><span class="p">;</span> <span class="n">e</span><span class="p">.</span><span class="n">detDistance</span> <span class="p">=</span> <span class="mf">1.2</span><span class="p">;</span>
<span class="n">e</span><span class="p">.</span><span class="n">refresh</span><span class="p">();</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Output arguments:</dt>
<dd>This function does not return any arguments.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="&#64;nanodiffraction.nanodiffraction.remove_semitransparent_object">
<code class="descname">remove_semitransparent_object</code><span class="sig-paren">(</span><em>im_in</em>, <em>phi1</em>, <em>phi2</em><span class="sig-paren">)</span><a class="headerlink" href="#@nanodiffraction.nanodiffraction.remove_semitransparent_object" title="Permalink to this definition">¶</a></dt>
<dd><p>REMOVE_SEMITRANSPARENT_OBJECT  Description.</p>
<blockquote>
<div><code class="docutils literal notranslate"><span class="pre">[image_out,correction]</span> <span class="pre">=</span> <span class="pre">remove_semitransparent_object(image,phi1,phi2)</span></code></div></blockquote>
<dl class="docutils">
<dt>The following arguments are supported:</dt>
<dd><dl class="first last docutils">
<dt>image: [] (required)</dt>
<dd>Description.</dd>
<dt>phi1: [] (required)</dt>
<dd>Description.</dd>
<dt>phi2: [] (required)</dt>
<dd>Description.</dd>
</dl>
</dd>
</dl>
<p class="rubric">Example</p>
<p>See the following example for help:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">Example</span> <span class="n">missing</span><span class="p">.</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Output arguments:</dt>
<dd><dl class="first last docutils">
<dt>image_out:</dt>
<dd>A corrected image.</dd>
<dt>correction:</dt>
<dd>A correction matrix.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="&#64;nanodiffraction.nanodiffraction.scan">
<code class="descname">scan</code><em class="property"> = u'struct'</em><a class="headerlink" href="#@nanodiffraction.nanodiffraction.scan" title="Permalink to this definition">¶</a></dt>
<dd><p>holds scan parameters</p>
</dd></dl>

<dl class="method">
<dt id="&#64;nanodiffraction.nanodiffraction.set_corr">
<code class="descname">set_corr</code><span class="sig-paren">(</span><em>corr</em><span class="sig-paren">)</span><a class="headerlink" href="#@nanodiffraction.nanodiffraction.set_corr" title="Permalink to this definition">¶</a></dt>
<dd><p>SET_CORR  Defines a correction matrix to be applied in a
subsequent analysis.
Note, that a warning will be shown, if the size of the
correction matrix does not correspond to the current detector
dimensions.</p>
<blockquote>
<div><code class="docutils literal notranslate"><span class="pre">[corr_out]</span> <span class="pre">=</span> <span class="pre">set_corr(corr)</span></code></div></blockquote>
<dl class="docutils">
<dt>The following arguments are supported:</dt>
<dd><dl class="first last docutils">
<dt>corr: []</dt>
<dd>A two-dimensional array. Input can a double array.</dd>
</dl>
</dd>
</dl>
<p class="rubric">Example</p>
<p>See the following example for help:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">e</span> <span class="p">=</span> <span class="n">nanodiffraction</span><span class="p">(</span><span class="o">&lt;</span><span class="n">some</span> <span class="n">settings</span><span class="o">&gt;</span><span class="p">);</span>
<span class="n">e</span><span class="p">.</span><span class="n">set_scan_info</span><span class="p">(</span><span class="s">&#39;SNy&#39;</span><span class="p">,</span><span class="mi">512</span><span class="p">,</span><span class="s">&#39;SNz&#39;</span><span class="p">,</span><span class="mi">651</span><span class="p">);</span>
<span class="n">mask</span> <span class="p">=</span> <span class="n">e</span><span class="p">.</span><span class="n">masks</span> <span class="o">|</span> <span class="n">e</span><span class="p">.</span><span class="n">azimuthal_mask</span><span class="p">(</span><span class="s">&#39;phi1&#39;</span><span class="p">,</span><span class="o">-</span><span class="mi">20</span><span class="p">,</span><span class="s">&#39;phi2&#39;</span><span class="p">,</span><span class="mi">20</span><span class="p">);</span>
<span class="n">bs</span> <span class="p">=</span> <span class="n">e</span><span class="p">.</span><span class="n">analyze_scan</span><span class="p">(</span><span class="s">&#39;method&#39;</span><span class="p">,</span><span class="s">&#39;average&#39;</span><span class="p">,</span><span class="s">&#39;zCrop&#39;</span><span class="p">,[</span><span class="mi">1</span> <span class="mi">2</span><span class="p">],</span><span class="s">&#39;yCrop&#39;</span><span class="p">,[</span><span class="mi">2</span> <span class="mi">1079</span><span class="p">]);</span>
<span class="n">rad_bgr</span> <span class="p">=</span> <span class="n">b1d</span><span class="p">(</span><span class="n">bs</span><span class="p">.</span><span class="n">avg</span><span class="p">,</span><span class="n">mask</span><span class="p">,[],</span><span class="n">e</span><span class="p">.</span><span class="n">qr</span><span class="p">,</span><span class="mi">512</span><span class="p">);</span>
<span class="n">vq2d</span> <span class="p">=</span> <span class="n">e</span><span class="p">.</span><span class="n">azimuthal_spread</span><span class="p">(</span><span class="n">rad_bgr</span><span class="p">.</span><span class="n">dat_1d</span><span class="p">,</span><span class="n">rad_bgr</span><span class="p">.</span><span class="n">qr</span><span class="p">);</span>
<span class="n">e</span><span class="p">.</span><span class="n">set_corr</span><span class="p">(</span><span class="o">~</span><span class="n">e</span><span class="p">.</span><span class="n">masks</span><span class="o">.*</span><span class="p">(</span><span class="n">vq2d</span><span class="o">./</span><span class="n">bs</span><span class="p">.</span><span class="n">avg</span><span class="p">));</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Output arguments:</dt>
<dd><dl class="first last docutils">
<dt>corr_out:</dt>
<dd>Active correction matrix</dd>
</dl>
</dd>
</dl>
<div class="line-block">
<div class="line">Note, that the correction matrix is stored in:</div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">(nanodiffraction_class).corr</span></code></div>
<div class="line">after set_corr was used.</div>
</div>
</dd></dl>

<dl class="method">
<dt id="&#64;nanodiffraction.nanodiffraction.set_mask">
<code class="descname">set_mask</code><span class="sig-paren">(</span><em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@nanodiffraction.nanodiffraction.set_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>SET_MASK  The function accepts as many masks as needed as
arguments, as long as their dimensions are identical.
Note, that a warning will be shown, if the size of the mask
does not correspond to the current detector dimensions.</p>
<blockquote>
<div><code class="docutils literal notranslate"><span class="pre">[mask_out]</span> <span class="pre">=</span> <span class="pre">set_mask(mask,</span> <span class="pre">mask,</span> <span class="pre">mask,</span> <span class="pre">...)</span></code></div></blockquote>
<dl class="docutils">
<dt>The following arguments are supported:</dt>
<dd><dl class="first last docutils">
<dt>mask: [] (required)</dt>
<dd>A two-dimensional array.The input should be a logical
array.</dd>
<dt>mask: [] (optional)</dt>
<dd>Additional masks can be given. All masks will then be
logically combined (OR combination [|]).</dd>
<dt>mask: [] (optional)</dt>
<dd>The amount of masks is not limited, all masks will then
be logically combined (OR combination [|]).</dd>
</dl>
</dd>
</dl>
<p class="rubric">Example</p>
<p>See the following example for help:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">e</span> <span class="p">=</span> <span class="n">nanodiffraction</span><span class="p">(</span><span class="o">&lt;</span><span class="n">some</span> <span class="n">settings</span><span class="o">&gt;</span><span class="p">);</span>
<span class="n">mask1</span> <span class="p">=</span> <span class="n">e</span><span class="p">.</span><span class="n">radial_mask</span><span class="p">(</span><span class="s">&#39;r1&#39;</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="s">&#39;r2&#39;</span><span class="p">,</span><span class="mf">0.2</span><span class="p">,</span><span class="s">&#39;grid&#39;</span><span class="p">,</span><span class="n">e</span><span class="p">.</span><span class="n">qr</span><span class="p">);</span>
<span class="n">mask2</span> <span class="p">=</span>
<span class="n">e</span><span class="p">.</span><span class="n">azimuthal_mask</span><span class="p">(</span><span class="s">&#39;phi1&#39;</span><span class="p">,</span><span class="mi">30</span><span class="p">,</span><span class="s">&#39;phi2&#39;</span><span class="p">,</span><span class="mi">56</span><span class="p">,</span><span class="s">&#39;grid&#39;</span><span class="p">,</span><span class="n">e</span><span class="p">.</span><span class="n">phi2</span><span class="p">);</span>
<span class="n">e</span><span class="p">.</span><span class="n">set_mask</span><span class="p">(</span><span class="n">mask1</span><span class="p">,</span><span class="n">mask2</span><span class="p">);</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Output arguments:</dt>
<dd><dl class="first last docutils">
<dt>mask_out:</dt>
<dd>Combined mask.</dd>
</dl>
</dd>
</dl>
<div class="line-block">
<div class="line">Note, that the detector mask is stored in:</div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">(nanodiffraction_class).mask</span></code></div>
</div>
</dd></dl>

<dl class="method">
<dt id="&#64;nanodiffraction.nanodiffraction.set_roi_and_binning">
<code class="descname">set_roi_and_binning</code><span class="sig-paren">(</span><em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@nanodiffraction.nanodiffraction.set_roi_and_binning" title="Permalink to this definition">¶</a></dt>
<dd><p>SET_ROI_AND_BINNING  All following functions require a standard
pixel mask that mask hot pixels and intermodular gaps of
detectors. In addition, a calibration could be added that
corrects for solid angle deviations at larger scattering
angles.</p>
<blockquote>
<div><code class="docutils literal notranslate"><span class="pre">set_roi_and_binning(options)</span></code></div></blockquote>
<dl class="docutils">
<dt>The following arguments are accepted:</dt>
<dd><dl class="first last docutils">
<dt>options: [] (optional)</dt>
<dd><p class="first">Structure that can contain the following fields. Note,
that all fields are optional. Default values that are
otherwise used are as usual given in angle brackets:</p>
<dl class="last docutils">
<dt>roi: []</dt>
<dd>Can be toggled between on and off</dd>
<dt>roiY: [start end]</dt>
<dd>[start end] in pixel units</dd>
<dt>roiZ: [start end]</dt>
<dd>[start end] in pixel units</dd>
<dt>binning: [1]</dt>
<dd>Can be toggled between on and off</dd>
<dt>binY: [1]</dt>
<dd>Binning ratio along y</dd>
<dt>binZ: [1]</dt>
<dd>Binning ratio along z</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Example</p>
<p>See the following example for help:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">e</span> <span class="p">=</span> <span class="n">nanodiffraction</span><span class="p">();</span>
<span class="n">e</span><span class="p">.</span><span class="n">set_roi_and_binning</span><span class="p">(</span><span class="s">&#39;roi&#39;</span><span class="p">,</span><span class="s">&#39;on&#39;</span><span class="p">,</span><span class="c">...</span>
<span class="s">&#39;roiY&#39;</span><span class="p">,</span><span class="n">around_y</span><span class="p">(</span><span class="mi">100</span><span class="p">),</span><span class="c">...</span>
<span class="s">&#39;roiZ&#39;</span><span class="p">,</span><span class="n">around_z</span><span class="p">(</span><span class="mi">100</span><span class="p">),</span><span class="c">...</span>
<span class="s">&#39;binning&#39;</span><span class="p">,</span><span class="s">&#39;on&#39;</span><span class="p">,</span><span class="c">...</span>
<span class="s">&#39;binY&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="c">...</span>
<span class="s">&#39;binZ&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Output arguments:</dt>
<dd>This function does not return any arguments.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="&#64;nanodiffraction.nanodiffraction.set_scan_info">
<code class="descname">set_scan_info</code><span class="sig-paren">(</span><em>sny</em>, <em>snz</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@nanodiffraction.nanodiffraction.set_scan_info" title="Permalink to this definition">¶</a></dt>
<dd><p>SET_SCAN_INFO  sets the scan information for all subsequent
analyses.</p>
<blockquote>
<div><code class="docutils literal notranslate"><span class="pre">set_scan_info(sny,snz,options)</span></code></div></blockquote>
<dl class="docutils">
<dt>The following arguments are supported:</dt>
<dd><dl class="first last docutils">
<dt>sny: [] (required)</dt>
<dd>number of scan points along fast axis</dd>
<dt>snz: [] (required)</dt>
<dd>number of scan points along slow axis</dd>
<dt>options: [] (optional)</dt>
<dd><p class="first">Structure that can contain the following fields. Note,
that all fields are optional. Default values that are
otherwise used are as usual given in angle brackets:</p>
<dl class="last docutils">
<dt>firstFile: [1]</dt>
<dd>Description.</dd>
<dt>stepY: [1e-6]</dt>
<dd>Description.</dd>
<dt>stepZ: [1e-6]</dt>
<dd>Description.</dd>
<dt>roi: []</dt>
<dd>Description.</dd>
<dt>roiMask: []</dt>
<dd>Description.</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Example</p>
<p>See the following example for help:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">e</span> <span class="p">=</span> <span class="n">nanodiffraction</span><span class="p">();</span>
<span class="n">e</span><span class="p">.</span><span class="n">set_scan_info</span><span class="p">(</span><span class="mi">51</span><span class="p">,</span><span class="mi">51</span><span class="p">);</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Output arguments:</dt>
<dd>This function does not return any arguments.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="&#64;nanodiffraction.nanodiffraction.set_selection">
<code class="descname">set_selection</code><span class="sig-paren">(</span><em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@nanodiffraction.nanodiffraction.set_selection" title="Permalink to this definition">¶</a></dt>
<dd><p>SET_SELECTION  The function accepts as many selections as
needed as arguments, as long as their dimensions are
identical.
Note, that a warning will be shown, if the size of the mask
does not correspond to the current detector dimensions.</p>
<blockquote>
<div>[sel_out] = set_selection(sel, sel, sel, …)</div></blockquote>
<dl class="docutils">
<dt>The following arguments are supported:</dt>
<dd><dl class="first last docutils">
<dt>sel: [] (required)</dt>
<dd>A two-dimensional array. The input should be a logical
array.</dd>
<dt>sel: [] (optional)</dt>
<dd>Additional selections can be given. All selections will
then be logically combined (OR combination [|]).</dd>
<dt>sel: [] (optional)</dt>
<dd>The amount of selections is not limited, all selections
will be combined to one.</dd>
</dl>
</dd>
</dl>
<p class="rubric">Example</p>
<p>See the following example for help:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">e</span> <span class="p">=</span> <span class="n">nanodiffraction</span><span class="p">(</span><span class="o">&lt;</span><span class="n">some</span> <span class="n">settings</span><span class="o">&gt;</span><span class="p">);</span>
<span class="n">sel_small</span> <span class="p">=</span> <span class="n">e</span><span class="p">.</span><span class="n">radial_mask</span><span class="p">(</span><span class="s">&#39;r1&#39;</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="s">&#39;r2&#39;</span><span class="p">,</span><span class="mf">1.2</span><span class="p">,</span><span class="s">&#39;grid&#39;</span><span class="p">,</span><span class="n">e</span><span class="p">.</span><span class="n">qr</span><span class="p">);</span>
<span class="n">sel_large</span> <span class="p">=</span> <span class="n">e</span><span class="p">.</span><span class="n">radial_mask</span><span class="p">(</span><span class="s">&#39;r1&#39;</span><span class="p">,</span><span class="mf">2.4</span><span class="p">,</span><span class="s">&#39;r2&#39;</span><span class="p">,</span><span class="mf">3.2</span><span class="p">,</span><span class="s">&#39;grid&#39;</span><span class="p">,</span><span class="n">e</span><span class="p">.</span><span class="n">qr</span><span class="p">);</span>
<span class="n">e</span><span class="p">.</span><span class="n">set_selection</span><span class="p">(</span><span class="n">sel_small</span><span class="p">,</span><span class="n">sel_large</span><span class="p">);</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Output arguments:</dt>
<dd><dl class="first last docutils">
<dt>sel_out:</dt>
<dd>Current selection.</dd>
</dl>
</dd>
<dt>Note, that selections are stored in:</dt>
<dd>(nanodiffraction_class).sels</dd>
</dl>
<div class="line-block">
<div class="line">Note, that more selections can be used, for example, when</div>
<div class="line">performing a pca analysis or stxm. Additional selections</div>
<div class="line">can be added by calling</div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">(nanodiffraction).add_selection(sel)</span></code></div>
</div>
<div class="line-block">
<div class="line">For more help, please read:</div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">help</span> <span class="pre">nanodiffraction.add_selection</span></code></div>
</div>
</dd></dl>

<dl class="method">
<dt id="&#64;nanodiffraction.nanodiffraction.simulate_actomyosin">
<code class="descname">simulate_actomyosin</code><span class="sig-paren">(</span><em>phi0</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@nanodiffraction.nanodiffraction.simulate_actomyosin" title="Permalink to this definition">¶</a></dt>
<dd><p>SIMULATE_ACTOMYOSIN  Description.</p>
<blockquote>
<div><code class="docutils literal notranslate"><span class="pre">simulation</span> <span class="pre">=</span> <span class="pre">simulate_actomyosin(opts)</span></code></div></blockquote>
<dl class="docutils">
<dt>The following arguments are supported:</dt>
<dd><dl class="first last docutils">
<dt>phi0: [see default values below] (optional)</dt>
<dd>Description.</dd>
</dl>
</dd>
</dl>
<p class="rubric">Example</p>
<p>See the following example for help:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">Example</span> <span class="n">missing</span><span class="p">.</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Output arguments:</dt>
<dd><dl class="first last docutils">
<dt>simulation:</dt>
<dd>A simulated diffraction pattern.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="&#64;nanodiffraction.nanodiffraction.simulate_agbh">
<code class="descname">simulate_agbh</code><span class="sig-paren">(</span><em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@nanodiffraction.nanodiffraction.simulate_agbh" title="Permalink to this definition">¶</a></dt>
<dd><p>SIMULATE_AGBH  Description.</p>
<blockquote>
<div><code class="docutils literal notranslate"><span class="pre">simulation</span> <span class="pre">=</span> <span class="pre">simulate_agbh(opts)</span></code></div></blockquote>
<dl class="docutils">
<dt>The following arguments are supported:</dt>
<dd><dl class="first last docutils">
<dt>opts: [see default values below] (optional)</dt>
<dd>Description.</dd>
</dl>
</dd>
</dl>
<p class="rubric">Example</p>
<p>See the following example for help:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">Example</span> <span class="n">missing</span><span class="p">.</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Output arguments:</dt>
<dd><dl class="first last docutils">
<dt>simulation:</dt>
<dd>A simulated diffraction pattern.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="&#64;nanodiffraction.nanodiffraction.simulate_airscattering">
<code class="descname">simulate_airscattering</code><span class="sig-paren">(</span><em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@nanodiffraction.nanodiffraction.simulate_airscattering" title="Permalink to this definition">¶</a></dt>
<dd><p>SIMULATE_AIRSCATTERING  simulates the effect of air
scattering.</p>
<blockquote>
<div><code class="docutils literal notranslate"><span class="pre">[bgr]</span> <span class="pre">=</span> <span class="pre">simulate_airscattering(opts)</span></code></div></blockquote>
<dl class="docutils">
<dt>The following arguments are supported:</dt>
<dd><dl class="first last docutils">
<dt>opts: [see default values below] (optional)</dt>
<dd><p class="first">Structure that can contain the following fields.
Note, that all fields are optional. Default values
that are otherwise used are as usual given in angle
brackets. All distances are given in millimeters.</p>
<dl class="last docutils">
<dt>l_pre:: [10]</dt>
<dd>Pre-distance.</dd>
<dt>l_post:: [10]</dt>
<dd>Post-distance.</dd>
<dt>l_sd:: [500]</dt>
<dd>Distance sample-to-detector</dd>
<dt>l_sampl:: [0.1]</dt>
<dd>Sampling interval.</dd>
<dt>ap_size:: [0.07]</dt>
<dd>Aperture size.</dd>
<dt>I0:: [1]</dt>
<dd>number of incident photons</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Example</p>
<p>See the following example for help:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">e</span> <span class="p">=</span> <span class="n">nanodiffraction</span><span class="p">();</span>
<span class="n">airscat</span> <span class="p">=</span> <span class="n">e</span><span class="p">.</span><span class="n">simulate_airscatting</span><span class="p">();</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Output arguments:</dt>
<dd><dl class="first last docutils">
<dt>bgr:</dt>
<dd>Simulated air-scattering background.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="&#64;nanodiffraction.nanodiffraction.simulate_bs">
<code class="descname">simulate_bs</code><span class="sig-paren">(</span><em>bs_size</em>, <em>bs_dist</em><span class="sig-paren">)</span><a class="headerlink" href="#@nanodiffraction.nanodiffraction.simulate_bs" title="Permalink to this definition">¶</a></dt>
<dd><p>SIMULATE_BS  Estimates the size of the beamstop that can be
expected projected on the detector.</p>
<blockquote>
<div><code class="docutils literal notranslate"><span class="pre">[bs_size_det_q]</span> <span class="pre">=</span> <span class="pre">simulate_bs(bs_size,</span> <span class="pre">bs_dist)</span></code></div></blockquote>
<dl class="docutils">
<dt>The following arguments are supported:</dt>
<dd><dl class="first last docutils">
<dt>bs_size: []</dt>
<dd>Diameter of beamstop in (mm)</dd>
<dt>bs_dist: []</dt>
<dd>Distance in (mm) behind focal spot</dd>
</dl>
</dd>
</dl>
<p class="rubric">Example</p>
<p>See the following example for help:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">e</span> <span class="p">=</span> <span class="n">nanodiffraction</span><span class="p">();</span>
<span class="n">bs</span> <span class="p">=</span> <span class="n">e</span><span class="p">.</span><span class="n">simulate_bs</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span><span class="mi">100</span><span class="p">);</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Output arguments:</dt>
<dd><dl class="first last docutils">
<dt>bs_size_det_q:</dt>
<dd>Size of a circular beamstop projected onto
the detector.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="&#64;nanodiffraction.nanodiffraction.simulate_streak">
<code class="descname">simulate_streak</code><span class="sig-paren">(</span><em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@nanodiffraction.nanodiffraction.simulate_streak" title="Permalink to this definition">¶</a></dt>
<dd><p>SIMULATE_STREAK  simulates a gaussian streak at the location
of the primary beam.</p>
<blockquote>
<div><code class="docutils literal notranslate"><span class="pre">[streak]</span> <span class="pre">=</span> <span class="pre">simulate_streak(opts)</span></code></div></blockquote>
<dl class="docutils">
<dt>The following arguments are supported:</dt>
<dd><dl class="first last docutils">
<dt>opts: [see default values below] (optional)</dt>
<dd><p class="first">Structure that can contain the following fields.
Note, that all fields are optional. Default values
that are otherwise used are as usual given in angle
brackets.</p>
<dl class="last docutils">
<dt>long: [0.005]</dt>
<dd>long axis length of streak</dd>
<dt>short: [0.05]</dt>
<dd>short axis length of streak</dd>
<dt>y: []</dt>
<dd>Description.</dd>
<dt>z: []</dt>
<dd>Description.</dd>
<dt>Ny: []</dt>
<dd>Number of horizontal detector pixels</dd>
<dt>Nz: []</dt>
<dd>Number of vertical detector pixels</dd>
<dt>angle: [30]</dt>
<dd>rotation angle of the streak</dd>
<dt>I0: [1]</dt>
<dd>number of incident photons</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Example</p>
<p>See the following example for help:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">e</span> <span class="p">=</span> <span class="n">nanodiffraction</span><span class="p">();</span>
<span class="n">streak</span> <span class="p">=</span> <span class="n">e</span><span class="p">.</span><span class="n">simulate_streak</span><span class="p">();</span>
<span class="n">imagesc</span><span class="p">(</span><span class="n">streak</span><span class="p">);</span> <span class="n">axis</span> <span class="n">image</span><span class="p">;</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Output arguments:</dt>
<dd><dl class="first last docutils">
<dt>streak:</dt>
<dd>A diffraction pattern containing a cigar-shaped
streak.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="&#64;nanodiffraction.nanodiffraction.stitch">
<code class="descname">stitch</code><span class="sig-paren">(</span><em>data</em>, <em>stitchy</em>, <em>stitchz</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@nanodiffraction.nanodiffraction.stitch" title="Permalink to this definition">¶</a></dt>
<dd><p>STITCH  takes a one-dimensional cell array of two-dimensional
data and combines all data into a single array, based on the
stitching dimensions.</p>
<blockquote>
<div><code class="docutils literal notranslate"><span class="pre">stitched</span> <span class="pre">=</span> <span class="pre">stitch(dataset,stitchy,stitchz,opts)</span></code></div></blockquote>
<dl class="docutils">
<dt>The following arguments are supported:</dt>
<dd><dl class="first last docutils">
<dt>dataset: [] (required)</dt>
<dd>One-dimensional cell array data{:} that contains
two-dimensional diffraction patterns of identical
dimensions.</dd>
<dt>stitchy: [] (required)</dt>
<dd>Number of images to be concatenated horizontally.</dd>
<dt>stitchz: [] (required)</dt>
<dd>Number of images to be concatenated vertically.</dd>
<dt>opts: [see default values below] (optional)</dt>
<dd><p class="first">Structure that can contain the following fields.
Note, that all fields are optional. Default values
that are otherwise used are as usual given in angle
brackets:</p>
<dl class="last docutils">
<dt>win: []</dt>
<dd>4-element vector containing the lower and upper
limits (in pixel units) along the horizontal and
lower and upper limits along the vertical dimension
of the scattering pattern.
Example: [100 900 100 900]</dd>
<dt>append: [0]</dt>
<dd>Appends N fields of zeros.</dd>
<dt>prepend: [0]</dt>
<dd>Prepends N fields of zeros.</dd>
<dt>replaceEmpty: [0]</dt>
<dd>If a cell array at a random location is empty, it
can be replaced by a field of zeros.</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Example</p>
<p>See the following example for help:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">Example</span> <span class="n">missing</span><span class="p">.</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Output arguments:</dt>
<dd><dl class="first last docutils">
<dt>stitched:</dt>
<dd>A stitched image.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="&#64;nanodiffraction.nanodiffraction.strip">
<code class="descname">strip</code><span class="sig-paren">(</span><em>data</em>, <em>winSize</em>, <em>iterations</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@nanodiffraction.nanodiffraction.strip" title="Permalink to this definition">¶</a></dt>
<dd><p>STRIP  Model-indepentend background stripping for
one-dimensional graphs with monotone background and
superimposted, sharp features such as bragg reflections or
spectral lines.</p>
<blockquote>
<div><code class="docutils literal notranslate"><span class="pre">stripped</span> <span class="pre">=</span> <span class="pre">strip(data,windowSize,iterations,qr)</span></code></div></blockquote>
<dl class="docutils">
<dt>The following arguments are supported:</dt>
<dd><dl class="first last docutils">
<dt>data: [] (required)</dt>
<dd>A one-dimensional array of data points.
See help: nanodiffraction.baseline.</dd>
<dt>windowSize: [] (required)</dt>
<dd>See help: nanodiffraction.baseline.</dd>
<dt>iterations: [] (required)</dt>
<dd>See help: nanodiffraction.baseline.</dd>
<dt>qr: [] (optional)</dt>
<dd>Detector coordinates in terms of the radial wavevector
transfer. A matrix of size [Nz,Ny] is expected.</dd>
</dl>
</dd>
</dl>
<p class="rubric">Example</p>
<p>See the following example for help:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">Example</span> <span class="n">missing</span><span class="p">.</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Output arguments:</dt>
<dd><dl class="first last docutils">
<dt>stripped:</dt>
<dd>stripped background</dd>
<dt>stripped_2d: (optional)</dt>
<dd>2d stripped background of size [Nz,Ny]. This is
only output if a two-dimensional qr-grid was given
to the function as optional argument.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="&#64;nanodiffraction.nanodiffraction.sub2ind">
<code class="descname">sub2ind</code><span class="sig-paren">(</span><em>y</em>, <em>z</em><span class="sig-paren">)</span><a class="headerlink" href="#@nanodiffraction.nanodiffraction.sub2ind" title="Permalink to this definition">¶</a></dt>
<dd><p>SUB2IND  calculates the linear index within the scan, based
on the row and column index.</p>
<blockquote>
<div><code class="docutils literal notranslate"><span class="pre">linear_index</span> <span class="pre">=</span> <span class="pre">sub2ind(col,row)</span></code></div></blockquote>
<dl class="docutils">
<dt>The following arguments are accepted:</dt>
<dd><dl class="first last docutils">
<dt>row: [] (required)</dt>
<dd>row index in scan (z-axis).</dd>
<dt>col: [] (required)</dt>
<dd>column index in scan (y-axis).</dd>
</dl>
</dd>
</dl>
<p class="rubric">Example</p>
<p>See the following example for help:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">Example</span> <span class="n">missing</span><span class="p">.</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Output arguments:</dt>
<dd><dl class="first last docutils">
<dt>linear_index:</dt>
<dd>Linear index.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="&#64;nanodiffraction.nanodiffraction.verify_array">
<code class="descname">verify_array</code><span class="sig-paren">(</span><em>arr_in</em>, <em>ref</em>, <em>process_handle</em><span class="sig-paren">)</span><a class="headerlink" href="#@nanodiffraction.nanodiffraction.verify_array" title="Permalink to this definition">¶</a></dt>
<dd><p>VERIFY_ARRAY  Description.</p>
<blockquote>
<div>output_array = verify_array(input_array, ref, process_handle)</div></blockquote>
<dl class="docutils">
<dt>The following arguments are supported:</dt>
<dd><dl class="first last docutils">
<dt>input_array: []</dt>
<dd>Description.</dd>
<dt>ref: []</dt>
<dd>Description.</dd>
<dt>process_handle: []</dt>
<dd>Description.</dd>
</dl>
</dd>
</dl>
<p class="rubric">Example</p>
<p>See the following example for help:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">Example</span> <span class="n">missing</span><span class="p">.</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Output arguments:</dt>
<dd><dl class="first last docutils">
<dt>output_array:</dt>
<dd>Description.</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../display/displayAPI.html" class="btn btn-neutral float-right" title="Display" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="../files/filesAPI.html" class="btn btn-neutral float-left" title="Files" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, Jan-David Nicolas

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>